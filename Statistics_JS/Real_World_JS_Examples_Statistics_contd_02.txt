Bubble Sort
Consider the following version of Bubble Sort:

for (int i = 0; i < n; i++) {
    // Track number of elements swapped during a single array traversal
    int numberOfSwaps = 0;
    
    for (int j = 0; j < n - 1; j++) {
        // Swap adjacent elements if they are in decreasing order
        if (a[j] > a[j + 1]) {
            swap(a[j], a[j + 1]);
            numberOfSwaps++;
        }
    }
    
    // If no elements were swapped during a traversal, array is sorted
    if (numberOfSwaps == 0) {
        break;
    }
}
Task:
Given an array, a, of size n distinct elements, sort the array in ascending order using the Bubble Sort algorithm above. Once sorted, print the following 3 lines:
1. Array is sorted in numSwaps swaps.
where numSwaps is the number of swaps that took place.
2. First Element: firstElement
where firstElement is the first element in the sorted array.
3. Last Element: lastElement
where lastElement is the last element in the sorted array.
Hint: To complete this challenge, you will need to add a variable that keeps a running tally of all swaps that occur during execution.
Example:
a = [4, 3, 1, 2]
original a: 4 3 1 2
round 1  a: 3 1 2 4 swaps this round: 3
round 2  a: 1 2 3 4 swaps this round: 2
round 3  a: 1 2 3 4 swaps this round: 0
In the first round, the 4 is swapped at each of the 3 comparisons, ending in the last position. In the second round, the 3 is swapped at 2 of the 3 comparisons. 
Finally, in the third round, no swaps are made so the iterations stop. The output is the following:
Array is sorted in 5 swaps.
First Element: 1
Last Element: 4
Input Format:
The first line contains an integer, n, the number of elements in array a.
The second line contains n space-separated integers that describe a[0],a[1], ...,a[n - 1].
Constraints:
2 <= n <= 600
1 <= a[i] <= 2x10^6, where 0 <= i < n.

'use strict';

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}



function main() {
    const n = parseInt(readLine().trim(), 10);

    const a = readLine().replace(/\s+$/g, '').split(' ').map(aTemp => parseInt(aTemp, 10));

    // Write your code here
}

---------------------------------------------------------------------------------
Multiple Linear Regression
Task:
Andrea has a simple equation:
Y = a + b1 . f1 + b1 . f2 + ... + bm . fm
for (m + 1) real constants (a, f1, f2, ...,fm ). We can say that the value of Y depends on m features. 
Andrea studies this equation for n different feature sets (f1, f2, f3, ..., fm) and records each respective value of Y. 
If she has q new feature sets, can you help Andrea find the value of Y for each of the sets?
Note: You are not expected to account for bias and variance trade-offs.
Input Format:
The first line contains 2 space-separated integers, m (the number of observed features) and n (the number of feature sets Andrea studied), respectively.
Each of the n subsequent lines contain m + 1 space-separated decimals; the first m elements are features (f1, f2, f3, ...,fm), 
and the last element is the value of Y for the line's feature set.
The next line contains a single integer, q, denoting the number of feature sets Andrea wants to query for.
Each of the q subsequent lines contains m space-separated decimals describing the feature sets.
Constraints:
1 <= m <= 10
5 <= n <= 100
0 <= x[i] <= 1
0 <= Y <= 10^6
1 <= q <= 100

function processData(input) {
    //Enter your code here
    let lines = input.trim().split('\n');
    let [m, n] = lines[0].trim().split(' ').map(Number);
    let X = [];
    let Y = [];
    for (let i = 1; i <= n; i++) {
        let arr = lines[i].trim().split(' ').map(Number);
        X.push([1, ...arr.slice(0, m)]); // Add bias term
        Y.push([arr[m]]);
    }
    let q = parseInt(lines[n + 1]);
    let queries = [];
    for (let i = n + 2; i < n + 2 + q; i++) {
        let arr = lines[i].trim().split(' ').map(Number);
        queries.push([1, ...arr]); // Add bias term
    }
    
    // Matrix operations
    function transpose(A) {
        return A[0].map((_, i) => A.map(row => row[i]));
    }
    function multiply(A, B) {
        let result = Array(A.length).fill(0).map(() => Array(B[0].length).fill(0));
        for (let i = 0; i < A.length; i++) {
            for (let j = 0; j < B[0].length; j++) {
                for (let k = 0; k < B.length; k++) {
                    result[i][j] += A[i][k] * B[k][j];
                }
            }
        }
        return result;
    }
    function inverse(A) {
        // Gauss-Jordan elimination for matrix inversion
        let n = A.length;
        let I = [];
        for (let i = 0; i < n; i++) {
            I[i] = [];
            for (let j = 0; j < n; j++) {
                I[i][j] = (i === j) ? 1 : 0;
            }
        }
        for (let i = 0; i < n; i++) {
            // Find the pivot
            let maxEl = Math.abs(A[i][i]);
            let maxRow = i;
            for (let k = i + 1; k < n; k++) {
                if (Math.abs(A[k][i]) > maxEl) {
                    maxEl = Math.abs(A[k][i]);
                    maxRow = k;
                }
            }
            // Swap rows
            [A[i], A[maxRow]] = [A[maxRow], A[i]];
            [I[i], I[maxRow]] = [I[maxRow], I[i]];
            // Make pivot = 1
            let pivot = A[i][i];
            for (let j = 0; j < n; j++) {
                A[i][j] /= pivot;
                I[i][j] /= pivot;
            }
            // Eliminate other rows
            for (let k = 0; k < n; k++) {
                if (k !== i) {
                    let c = A[k][i];
                    for (let j = 0; j < n; j++) {
                        A[k][j] -= c * A[i][j];
                        I[k][j] -= c * I[i][j];
                    }
                }
            }
        }
        return I;
    }
    
    // Normal Equation: B = (X^T X)^-1 X^T Y
    let XT = transpose(X);
    let XTX = multiply(XT, X);
    let XTX_inv = inverse(XTX);
    let XTY = multiply(XT, Y);
    let B = multiply(XTX_inv, XTY); // B is (m+1)x1

    // Predict for each query
    for (let i = 0; i < queries.length; i++) {
        let features = queries[i];
        let y_pred = 0;
        for (let j = 0; j < B.length; j++) {
            y_pred += B[j][0] * features[j];
        }
        console.log(y_pred.toFixed(2));
    }
} 

process.stdin.resume();
process.stdin.setEncoding("ascii");
_input = "";
process.stdin.on("data", function (input) {
    _input += input;
});

process.stdin.on("end", function () {
   processData(_input);
});



What is Node.js primarily used for?
a) Running JavaScript in the browser
b) Running JS on the server side   <-------------
c) Managing client-side DOM manipulation
d) Writing HTML and CSS


What is one advantage of utilizing Node.js?
a) Access to a diverse set of programming language
b) Ability to develop complex browser-based applications
c) Extensive ecosystem of packages <-----
d) Integration with hardware devices


What is the main purpose of a package.json file in a Node.js project?
a) Storing JS code sniplets
b) Defining project dependencies and metadata  <------------
c) Configuring server-side routing
d) Managing database connections


What is the role of GitHub in the context of sharing code?
a) Hosting Node.js packages
b) Backing up and version controlling code   <-----------------
c) Installing dependencies for Node.js projects
d) Managing client-side resources

What is the primary function of NPM (Node Package Manager) in the Node.js ecosystem?
a) Hosting code repositories
b) Providing a platform for code execution
c) Managing and distributing Node.js packages   <--------
d) Generating HTML templates


What is the purpose of the package.json file in a Node.js project?
a) To specify project dependencies <-----
b) To define project metadata
c) To store project documentation
d) To list project contributors


Which command is used to initialize a Node.js project and create a package.json file with default settings without going through prompts?
a) npm init -y <--------
b) npm start
c) npm install
d) npm create


What is the purpose of the node_modules directory in a Node.js project?
a) To store installed dependencies  <-------
b) To execute Node.js code
c) To cache JS files
d) To store project configuration


How do you install a package named "faker" in a Node.js project using npm?
a) npm install faker  <--------
b) npm add faker
c) npm get faker
d) npm save faker


What is the purpose of the package-lock.json file in a Node.js project?
a) To lock dependency versions  <--------
b) To specify project metadata
c) To store project documentation
d) To list project contributors

------------------------------------------------------------------------------------------------
Sales by Match
There is a large pile of socks that must be paired by color. Given an array of integers representing the color of each sock, determine how many pairs of socks with matching colors there are.
Example:
n = 7
ar = [1,2,1,2,1,3,2]
There is one pair of color 1 and one of color 2. There are three odd socks left, one of each color. The number of pairs is 2.
Function Description:
Complete the sockMerchant function in the editor below.
sockMerchant has the following parameter(s):
* int n: the number of socks in the pile
* int ar[n]: the colors of each sock
Returns:
int: the number of pairs
Input Format:
The first line contains an integer n, the number of socks represented in ar.
The second line contains n space-separated integers, ar[i], the colors of the socks in the pile.
Constraints:
1 <= n <= 100
1 <= ar[i] <= 100 where 0 <= i < n

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}

/*
 * Complete the 'sockMerchant' function below.
 *
 * The function is expected to return an INTEGER.
 * The function accepts following parameters:
 *  1. INTEGER n
 *  2. INTEGER_ARRAY ar
 */

function sockMerchant(n, ar) {
    // Write your code here

}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const n = parseInt(readLine().trim(), 10);

    const ar = readLine().replace(/\s+$/g, '').split(' ').map(arTemp => parseInt(arTemp, 10));

    const result = sockMerchant(n, ar);

    ws.write(result + '\n');

    ws.end();
}

----------------------------------

Binary Search Trees
Task:
A level-order traversal, also known as a breadth-first search, visits each level of a tree's nodes from left to right, top to bottom. You are given a pointer, root, 
pointing to the root of a binary search tree. Complete the levelOrder function provided in your editor so that it prints the level-order traversal of the binary search tree.
Hint: You'll find a queue helpful in completing this challenge.
Function Description:
Complete the levelOrder function in the editor below.
levelOrder has the following parameter:
- Node pointer root: a reference to the root of the tree
Prints:
- Print node.data items as space-separated line of integers. No return value is expected.
Input Format:
The locked stub code in your editor reads the following inputs and assembles them into a BST:
The first line contains an integer, T (the number of test cases).
The T subsequent lines each contain an integer, data, denoting the value of an element that must be added to the BST.
Constraints:
1 <= N <= 20
1 <= node, data[i] <= 100

// Start of function Node
function Node(data) {
    this.data = data;
    this.left = null;
    this.right = null;
}; // End of function Node

// Start of function BinarySearchTree
function BinarySearchTree() {
    this.insert = function(root, data) {
        if (root === null) {
            this.root = new Node(data);
            
            return this.root;
        }
        
        if (data <= root.data) {
            if (root.left) {
                this.insert(root.left, data);
            } else {
                root.left = new Node(data);
            }
        } else {
            if (root.right) {
                this.insert(root.right, data);
            } else {
                root.right = new Node(data);
            }
        }
        
        return this.root;
    };
    
    // Start of function levelOrder
    this.levelOrder = function(root) {

        // Add your code here
        // To print values separated by spaces use process.stdout.write(someValue + ' ')

	}; // End of function levelOrder
}; // End of function BinarySearchTree

process.stdin.resume();
process.stdin.setEncoding('ascii');

var _input = "";

process.stdin.on('data', function (data) {
    _input += data;
});

process.stdin.on('end', function () {
    var tree = new BinarySearchTree();
    var root = null;
    
    var values = _input.split('\n').map(Number);
    
    for (var i = 1; i < values.length; i++) {
        root = tree.insert(root, values[i]);
    }
    
    tree.levelOrder(root);
});

---------------------------------------------------------------------------------------------------------
Generics:
Task:( C++11)
Write a single generic function named printArray; this function must take an array of generic elements as a parameter (the exception to this is C++, which takes a vector). 
The locked Solution class in your editor tests your function.
Note: You must use generics to solve this challenge. Do not write overloaded functions.
Input Format:
The locked Solution class in your editor will pass different types of arrays to your printArray function.
Constraints:
You must have exactly 1 function named printArray.
Output Format:
Your printArray function should print each element of its generic array parameter on a new line.
#include <iostream>
#include <vector>
#include <string>

using namespace std;

/**
*    Name: printArray
*    Print each element of the generic vector on a new line. Do not return anything.
*    @param A generic vector
**/

// Write your code here

int main() {
	int n;
	
	cin >> n;
	vector<int> int_vector(n);
	for (int i = 0; i < n; i++) {
		int value;
		cin >> value;
		int_vector[i] = value;
	}
	
	cin >> n;
	vector<string> string_vector(n);
	for (int i = 0; i < n; i++) {
		string value;
		cin >> value;
		string_vector[i] = value;
	}

	printArray<int>(int_vector);
	printArray<string>(string_vector);

	return 0;
}

--------------------------------------------------------------------
Binary Search Trees
Task:
The height of a binary search tree is the number of edges between the tree's root and its furthest leaf. 
You are given a pointer, root, pointing to the root of a binary search tree. Complete the getHeight function provided in your editor 
so that it returns the height of the binary search tree.
Input Format:
The locked stub code in your editor reads the following inputs and assembles them into a binary search tree:
The first line contains an integer, n, denoting the number of nodes in the tree.
Each of the n subsequent lines contains an integer, data, denoting the value of an element that must be added to the BST.

// Start of function Node
function Node(data) {
    this.data = data;
    this.left = null;
    this.right = null;
}; // End of function Node

// Start of function BinarySearchTree
function BinarySearchTree() {
    this.insert = function(root, data) {
        if (root === null) {
            this.root = new Node(data);
            
            return this.root;
        }
        
        if (data <= root.data) {
            if (root.left) {
                this.insert(root.left, data);
            } else {
                root.left = new Node(data);
            }
        } else {
            if (root.right) {
                this.insert(root.right, data);
            } else {
                root.right = new Node(data);
            }
        }
        
        return this.root;
    };
    
    // Start of function getHeight
    this.getHeight = function(root) {
        if (root === null) {
            return -1;
        }
        let leftHeight = this.getHeight(root.left);
        let rightHeight = this.getHeight(root.right);
        return 1 + Math.max(leftHeight, rightHeight);
    }; // End of function getHeight
}; // End of function BinarySearchTree

process.stdin.resume();
process.stdin.setEncoding('ascii');

var _input = "";

process.stdin.on('data', function (data) {
    _input += data;
});

process.stdin.on('end', function () {
    var tree = new BinarySearchTree();
    var root = null;
    
    var values = _input.split('\n').map(Number);
    
    for (var i = 1; i < values.length; i++) {
        root = tree.insert(root, values[i]);
    }
    
    console.log(tree.getHeight(root));
});

-------------------------------------------------------------

Given an array of n distinct integers, transform the array into a zig zag sequence by permuting the array elements. 
A sequence will be called a zig zag sequence if the first k elements in the sequence are in increasing order and the last k elements are in decreasing order, 
where k = (n + 1) / 2. You need to find the lexicographically smallest zig zag sequence of the given array.
Example:
a = [2,3,5,1,4]
Now if we permute the array as [1,4,5,3,2], the result is a zig zag sequence.
Debug the given function findZigZagSequence to return the appropriate zig zag sequence for the given input array.
Note: You can modify at most three lines in the given code. You cannot add or remove lines of code.
To restore the original code, click on the icon to the right of the language selector.
Input Format:
The first line contains t the number of test cases. The first line of each test case contains an integer n, 
denoting the number of array elements. The next line of the test case contains n elements of array a.
Constraints:
1 <= t <= 20
1 <= n <= 10000 (n is always odd)
1 <= a[i] <= 10^9

function findZigZagSequence(a, n) {
    a.sort((x, y) => x - y);
    let mid = Math.floor((n - 1) / 2);
    // Swap middle and last element
    let temp = a[mid];
    a[mid] = a[n - 1];
    a[n - 1] = temp;
    // Reverse the second half after the middle element
    let st = mid + 1;
    let ed = n - 2;
    while (st <= ed) {
        let tmp = a[st];
        a[st] = a[ed];
        a[ed] = tmp;
        st++;
        ed--;
    }
    return a;
}
function processData(input) {
    //Enter your code here
    let lines = input.trim().split('\n');
    let t = parseInt(lines[0]);
    let idx = 1;
    for (let i = 0; i < t; i++) {
        let n = parseInt(lines[idx++]);
        let a = lines[idx++].split(' ').map(Number);
        let result = findZigZagSequence(a, n);
        console.log(result.join(' '));
    }
} 

process.stdin.resume();
process.stdin.setEncoding("ascii");
_input = "";
process.stdin.on("data", function (input) {
    _input += input;
});

process.stdin.on("end", function () {
   processData(_input);
});
------------------------------------------------------------------------




























