Bubble Sort
Consider the following version of Bubble Sort:

for (int i = 0; i < n; i++) {
    // Track number of elements swapped during a single array traversal
    int numberOfSwaps = 0;
    
    for (int j = 0; j < n - 1; j++) {
        // Swap adjacent elements if they are in decreasing order
        if (a[j] > a[j + 1]) {
            swap(a[j], a[j + 1]);
            numberOfSwaps++;
        }
    }
    
    // If no elements were swapped during a traversal, array is sorted
    if (numberOfSwaps == 0) {
        break;
    }
}
Task:
Given an array, a, of size n distinct elements, sort the array in ascending order using the Bubble Sort algorithm above. Once sorted, print the following 3 lines:
1. Array is sorted in numSwaps swaps.
where numSwaps is the number of swaps that took place.
2. First Element: firstElement
where firstElement is the first element in the sorted array.
3. Last Element: lastElement
where lastElement is the last element in the sorted array.
Hint: To complete this challenge, you will need to add a variable that keeps a running tally of all swaps that occur during execution.
Example:
a = [4, 3, 1, 2]
original a: 4 3 1 2
round 1  a: 3 1 2 4 swaps this round: 3
round 2  a: 1 2 3 4 swaps this round: 2
round 3  a: 1 2 3 4 swaps this round: 0
In the first round, the 4 is swapped at each of the 3 comparisons, ending in the last position. In the second round, the 3 is swapped at 2 of the 3 comparisons. 
Finally, in the third round, no swaps are made so the iterations stop. The output is the following:
Array is sorted in 5 swaps.
First Element: 1
Last Element: 4
Input Format:
The first line contains an integer, n, the number of elements in array a.
The second line contains n space-separated integers that describe a[0],a[1], ...,a[n - 1].
Constraints:
2 <= n <= 600
1 <= a[i] <= 2x10^6, where 0 <= i < n.

'use strict';

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}



function main() {
    const n = parseInt(readLine().trim(), 10);

    const a = readLine().replace(/\s+$/g, '').split(' ').map(aTemp => parseInt(aTemp, 10));

    // Write your code here
}

---------------------------------------------------------------------------------
Multiple Linear Regression
Task:
Andrea has a simple equation:
Y = a + b1 . f1 + b1 . f2 + ... + bm . fm
for (m + 1) real constants (a, f1, f2, ...,fm ). We can say that the value of Y depends on m features. 
Andrea studies this equation for n different feature sets (f1, f2, f3, ..., fm) and records each respective value of Y. 
If she has q new feature sets, can you help Andrea find the value of Y for each of the sets?
Note: You are not expected to account for bias and variance trade-offs.
Input Format:
The first line contains 2 space-separated integers, m (the number of observed features) and n (the number of feature sets Andrea studied), respectively.
Each of the n subsequent lines contain m + 1 space-separated decimals; the first m elements are features (f1, f2, f3, ...,fm), 
and the last element is the value of Y for the line's feature set.
The next line contains a single integer, q, denoting the number of feature sets Andrea wants to query for.
Each of the q subsequent lines contains m space-separated decimals describing the feature sets.
Constraints:
1 <= m <= 10
5 <= n <= 100
0 <= x[i] <= 1
0 <= Y <= 10^6
1 <= q <= 100

function processData(input) {
    //Enter your code here
    let lines = input.trim().split('\n');
    let [m, n] = lines[0].trim().split(' ').map(Number);
    let X = [];
    let Y = [];
    for (let i = 1; i <= n; i++) {
        let arr = lines[i].trim().split(' ').map(Number);
        X.push([1, ...arr.slice(0, m)]); // Add bias term
        Y.push([arr[m]]);
    }
    let q = parseInt(lines[n + 1]);
    let queries = [];
    for (let i = n + 2; i < n + 2 + q; i++) {
        let arr = lines[i].trim().split(' ').map(Number);
        queries.push([1, ...arr]); // Add bias term
    }
    
    // Matrix operations
    function transpose(A) {
        return A[0].map((_, i) => A.map(row => row[i]));
    }
    function multiply(A, B) {
        let result = Array(A.length).fill(0).map(() => Array(B[0].length).fill(0));
        for (let i = 0; i < A.length; i++) {
            for (let j = 0; j < B[0].length; j++) {
                for (let k = 0; k < B.length; k++) {
                    result[i][j] += A[i][k] * B[k][j];
                }
            }
        }
        return result;
    }
    function inverse(A) {
        // Gauss-Jordan elimination for matrix inversion
        let n = A.length;
        let I = [];
        for (let i = 0; i < n; i++) {
            I[i] = [];
            for (let j = 0; j < n; j++) {
                I[i][j] = (i === j) ? 1 : 0;
            }
        }
        for (let i = 0; i < n; i++) {
            // Find the pivot
            let maxEl = Math.abs(A[i][i]);
            let maxRow = i;
            for (let k = i + 1; k < n; k++) {
                if (Math.abs(A[k][i]) > maxEl) {
                    maxEl = Math.abs(A[k][i]);
                    maxRow = k;
                }
            }
            // Swap rows
            [A[i], A[maxRow]] = [A[maxRow], A[i]];
            [I[i], I[maxRow]] = [I[maxRow], I[i]];
            // Make pivot = 1
            let pivot = A[i][i];
            for (let j = 0; j < n; j++) {
                A[i][j] /= pivot;
                I[i][j] /= pivot;
            }
            // Eliminate other rows
            for (let k = 0; k < n; k++) {
                if (k !== i) {
                    let c = A[k][i];
                    for (let j = 0; j < n; j++) {
                        A[k][j] -= c * A[i][j];
                        I[k][j] -= c * I[i][j];
                    }
                }
            }
        }
        return I;
    }
    
    // Normal Equation: B = (X^T X)^-1 X^T Y
    let XT = transpose(X);
    let XTX = multiply(XT, X);
    let XTX_inv = inverse(XTX);
    let XTY = multiply(XT, Y);
    let B = multiply(XTX_inv, XTY); // B is (m+1)x1

    // Predict for each query
    for (let i = 0; i < queries.length; i++) {
        let features = queries[i];
        let y_pred = 0;
        for (let j = 0; j < B.length; j++) {
            y_pred += B[j][0] * features[j];
        }
        console.log(y_pred.toFixed(2));
    }
} 

process.stdin.resume();
process.stdin.setEncoding("ascii");
_input = "";
process.stdin.on("data", function (input) {
    _input += input;
});

process.stdin.on("end", function () {
   processData(_input);
});



What is Node.js primarily used for?
a) Running JavaScript in the browser
b) Running JS on the server side   <-------------
c) Managing client-side DOM manipulation
d) Writing HTML and CSS


What is one advantage of utilizing Node.js?
a) Access to a diverse set of programming language
b) Ability to develop complex browser-based applications
c) Extensive ecosystem of packages <-----
d) Integration with hardware devices


What is the main purpose of a package.json file in a Node.js project?
a) Storing JS code sniplets
b) Defining project dependencies and metadata  <------------
c) Configuring server-side routing
d) Managing database connections


What is the role of GitHub in the context of sharing code?
a) Hosting Node.js packages
b) Backing up and version controlling code   <-----------------
c) Installing dependencies for Node.js projects
d) Managing client-side resources

What is the primary function of NPM (Node Package Manager) in the Node.js ecosystem?
a) Hosting code repositories
b) Providing a platform for code execution
c) Managing and distributing Node.js packages   <--------
d) Generating HTML templates


What is the purpose of the package.json file in a Node.js project?
a) To specify project dependencies <-----
b) To define project metadata
c) To store project documentation
d) To list project contributors


Which command is used to initialize a Node.js project and create a package.json file with default settings without going through prompts?
a) npm init -y <--------
b) npm start
c) npm install
d) npm create


What is the purpose of the node_modules directory in a Node.js project?
a) To store installed dependencies  <-------
b) To execute Node.js code
c) To cache JS files
d) To store project configuration


How do you install a package named "faker" in a Node.js project using npm?
a) npm install faker  <--------
b) npm add faker
c) npm get faker
d) npm save faker


What is the purpose of the package-lock.json file in a Node.js project?
a) To lock dependency versions  <--------
b) To specify project metadata
c) To store project documentation
d) To list project contributors

------------------------------------------------------------------------------------------------
Sales by Match
There is a large pile of socks that must be paired by color. Given an array of integers representing the color of each sock, determine how many pairs of socks with matching colors there are.
Example:
n = 7
ar = [1,2,1,2,1,3,2]
There is one pair of color 1 and one of color 2. There are three odd socks left, one of each color. The number of pairs is 2.
Function Description:
Complete the sockMerchant function in the editor below.
sockMerchant has the following parameter(s):
* int n: the number of socks in the pile
* int ar[n]: the colors of each sock
Returns:
int: the number of pairs
Input Format:
The first line contains an integer n, the number of socks represented in ar.
The second line contains n space-separated integers, ar[i], the colors of the socks in the pile.
Constraints:
1 <= n <= 100
1 <= ar[i] <= 100 where 0 <= i < n

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}

/*
 * Complete the 'sockMerchant' function below.
 *
 * The function is expected to return an INTEGER.
 * The function accepts following parameters:
 *  1. INTEGER n
 *  2. INTEGER_ARRAY ar
 */

function sockMerchant(n, ar) {
    // Write your code here

}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const n = parseInt(readLine().trim(), 10);

    const ar = readLine().replace(/\s+$/g, '').split(' ').map(arTemp => parseInt(arTemp, 10));

    const result = sockMerchant(n, ar);

    ws.write(result + '\n');

    ws.end();
}

----------------------------------

Binary Search Trees
Task:
A level-order traversal, also known as a breadth-first search, visits each level of a tree's nodes from left to right, top to bottom. You are given a pointer, root, 
pointing to the root of a binary search tree. Complete the levelOrder function provided in your editor so that it prints the level-order traversal of the binary search tree.
Hint: You'll find a queue helpful in completing this challenge.
Function Description:
Complete the levelOrder function in the editor below.
levelOrder has the following parameter:
- Node pointer root: a reference to the root of the tree
Prints:
- Print node.data items as space-separated line of integers. No return value is expected.
Input Format:
The locked stub code in your editor reads the following inputs and assembles them into a BST:
The first line contains an integer, T (the number of test cases).
The T subsequent lines each contain an integer, data, denoting the value of an element that must be added to the BST.
Constraints:
1 <= N <= 20
1 <= node, data[i] <= 100

// Start of function Node
function Node(data) {
    this.data = data;
    this.left = null;
    this.right = null;
}; // End of function Node

// Start of function BinarySearchTree
function BinarySearchTree() {
    this.insert = function(root, data) {
        if (root === null) {
            this.root = new Node(data);
            
            return this.root;
        }
        
        if (data <= root.data) {
            if (root.left) {
                this.insert(root.left, data);
            } else {
                root.left = new Node(data);
            }
        } else {
            if (root.right) {
                this.insert(root.right, data);
            } else {
                root.right = new Node(data);
            }
        }
        
        return this.root;
    };
    
    // Start of function levelOrder
    this.levelOrder = function(root) {

        // Add your code here
        // To print values separated by spaces use process.stdout.write(someValue + ' ')

	}; // End of function levelOrder
}; // End of function BinarySearchTree

process.stdin.resume();
process.stdin.setEncoding('ascii');

var _input = "";

process.stdin.on('data', function (data) {
    _input += data;
});

process.stdin.on('end', function () {
    var tree = new BinarySearchTree();
    var root = null;
    
    var values = _input.split('\n').map(Number);
    
    for (var i = 1; i < values.length; i++) {
        root = tree.insert(root, values[i]);
    }
    
    tree.levelOrder(root);
});

---------------------------------------------------------------------------------------------------------
Generics:
Task:( C++11)
Write a single generic function named printArray; this function must take an array of generic elements as a parameter (the exception to this is C++, which takes a vector). 
The locked Solution class in your editor tests your function.
Note: You must use generics to solve this challenge. Do not write overloaded functions.
Input Format:
The locked Solution class in your editor will pass different types of arrays to your printArray function.
Constraints:
You must have exactly 1 function named printArray.
Output Format:
Your printArray function should print each element of its generic array parameter on a new line.
#include <iostream>
#include <vector>
#include <string>

using namespace std;

/**
*    Name: printArray
*    Print each element of the generic vector on a new line. Do not return anything.
*    @param A generic vector
**/

// Write your code here

int main() {
	int n;
	
	cin >> n;
	vector<int> int_vector(n);
	for (int i = 0; i < n; i++) {
		int value;
		cin >> value;
		int_vector[i] = value;
	}
	
	cin >> n;
	vector<string> string_vector(n);
	for (int i = 0; i < n; i++) {
		string value;
		cin >> value;
		string_vector[i] = value;
	}

	printArray<int>(int_vector);
	printArray<string>(string_vector);

	return 0;
}

--------------------------------------------------------------------
Binary Search Trees
Task:
The height of a binary search tree is the number of edges between the tree's root and its furthest leaf. 
You are given a pointer, root, pointing to the root of a binary search tree. Complete the getHeight function provided in your editor 
so that it returns the height of the binary search tree.
Input Format:
The locked stub code in your editor reads the following inputs and assembles them into a binary search tree:
The first line contains an integer, n, denoting the number of nodes in the tree.
Each of the n subsequent lines contains an integer, data, denoting the value of an element that must be added to the BST.

// Start of function Node
function Node(data) {
    this.data = data;
    this.left = null;
    this.right = null;
}; // End of function Node

// Start of function BinarySearchTree
function BinarySearchTree() {
    this.insert = function(root, data) {
        if (root === null) {
            this.root = new Node(data);
            
            return this.root;
        }
        
        if (data <= root.data) {
            if (root.left) {
                this.insert(root.left, data);
            } else {
                root.left = new Node(data);
            }
        } else {
            if (root.right) {
                this.insert(root.right, data);
            } else {
                root.right = new Node(data);
            }
        }
        
        return this.root;
    };
    
    // Start of function getHeight
    this.getHeight = function(root) {
        if (root === null) {
            return -1;
        }
        let leftHeight = this.getHeight(root.left);
        let rightHeight = this.getHeight(root.right);
        return 1 + Math.max(leftHeight, rightHeight);
    }; // End of function getHeight
}; // End of function BinarySearchTree

process.stdin.resume();
process.stdin.setEncoding('ascii');

var _input = "";

process.stdin.on('data', function (data) {
    _input += data;
});

process.stdin.on('end', function () {
    var tree = new BinarySearchTree();
    var root = null;
    
    var values = _input.split('\n').map(Number);
    
    for (var i = 1; i < values.length; i++) {
        root = tree.insert(root, values[i]);
    }
    
    console.log(tree.getHeight(root));
});

-------------------------------------------------------------

Given an array of n distinct integers, transform the array into a zig zag sequence by permuting the array elements. 
A sequence will be called a zig zag sequence if the first k elements in the sequence are in increasing order and the last k elements are in decreasing order, 
where k = (n + 1) / 2. You need to find the lexicographically smallest zig zag sequence of the given array.
Example:
a = [2,3,5,1,4]
Now if we permute the array as [1,4,5,3,2], the result is a zig zag sequence.
Debug the given function findZigZagSequence to return the appropriate zig zag sequence for the given input array.
Note: You can modify at most three lines in the given code. You cannot add or remove lines of code.
To restore the original code, click on the icon to the right of the language selector.
Input Format:
The first line contains t the number of test cases. The first line of each test case contains an integer n, 
denoting the number of array elements. The next line of the test case contains n elements of array a.
Constraints:
1 <= t <= 20
1 <= n <= 10000 (n is always odd)
1 <= a[i] <= 10^9

function findZigZagSequence(a, n) {
    a.sort((x, y) => x - y);
    let mid = Math.floor((n - 1) / 2);
    // Swap middle and last element
    let temp = a[mid];
    a[mid] = a[n - 1];
    a[n - 1] = temp;
    // Reverse the second half after the middle element
    let st = mid + 1;
    let ed = n - 2;
    while (st <= ed) {
        let tmp = a[st];
        a[st] = a[ed];
        a[ed] = tmp;
        st++;
        ed--;
    }
    return a;
}
function processData(input) {
    //Enter your code here
    let lines = input.trim().split('\n');
    let t = parseInt(lines[0]);
    let idx = 1;
    for (let i = 0; i < t; i++) {
        let n = parseInt(lines[idx++]);
        let a = lines[idx++].split(' ').map(Number);
        let result = findZigZagSequence(a, n);
        console.log(result.join(' '));
    }
} 

process.stdin.resume();
process.stdin.setEncoding("ascii");
_input = "";
process.stdin.on("data", function (input) {
    _input += input;
});

process.stdin.on("end", function () {
   processData(_input);
});
------------------------------------------------------------------------


Linked Lists
Task:
A Node class is provided for you in the editor. A Node object has an integer data field, data, and a Node instance pointer, next, 
pointing to another node (i.e.: the next node in a list).
A removeDuplicates function is declared in your editor, which takes a pointer to the head node of a linked list as a parameter. 
Complete removeDuplicates so that it deletes any duplicate nodes from the list and returns the head of the updated list.
Note: The head pointer may be null, indicating that the list is empty. Be sure to reset your next pointer when performing deletions to avoid breaking the list.
Input Format:
You do not need to read any input from stdin. The following input is handled by the locked stub code and passed to the removeDuplicates function:
The first line contains an integer, N, the number of nodes to be inserted.
The N subsequent lines each contain an integer describing the data value of a node being inserted at the list's tail.
Constraints:
The data elements of the linked list argument will always be in non-decreasing order.

process.stdin.resume();
process.stdin.setEncoding('ascii');

var input_stdin = "";
var input_stdin_array = "";
var input_currentline = 0;

process.stdin.on('data', function (data) {
    input_stdin += data;
});

process.stdin.on('end', function () {
    input_stdin_array = input_stdin.split("\n");
    main();    
});
function readLine() {
    return input_stdin_array[input_currentline++];
}
function Node(data){
    this.data=data;
    this.next=null;
}
function Solution(){

    this.removeDuplicates=function(head){
      //Write your code here
	let current = head;
        while (current !== null && current.next !== null) {
            if (current.data === current.next.data) {
                current.next = current.next.next;
            } else {
                current = current.next;
            }
        }
        return head;
    
    }

	this.insert=function(head,data){
        var p=new Node(data);
        if(head==null){
            head=p;
        }
        else if(head.next==null){
            head.next=p;
        }
        else{
            var start=head;
            while(start.next!=null){
                start=start.next;
            }
            start.next=p;
        }
        return head;
        
    };

	this.display=function(head){
        var start=head;
            while(start){
                process.stdout.write(start.data+" ");
                start=start.next;
            }
    };
}
function main(){
    var T=parseInt(readLine());
    var head=null;
    var mylist=new Solution();
    for(i=0;i<T;i++){
        var data=parseInt(readLine());
        head=mylist.insert(head,data);
    }
    head=mylist.removeDuplicates(head);
    mylist.display(head);
}		

--------------------------------------------------------------

Drawing Book:
A teacher asks the class to open their books to a page number. A student can either start turning pages from the front of the book or from the back of the book. 
They always turn pages one at a time. When they open the book, page 1 is always on the right side.
When they flip page 1, they see pages 2 and 3. Each page except the last page will always be printed on both sides. 
The last page may only be printed on the front, given the length of the book. If the book is n pages long, and a student wants to turn to page p, 
what is the minimum number of pages to turn? They can start at the beginning or the end of the book.
Given n and p, find and print the minimum number of pages that must be turned in order to arrive at page p.
Example:
n = 5
p = 3
Using the diagram above, if the student wants to get to page 3, they open the book to page 1, 
flip 1 page and they are on the correct page. If they open the book to the last page, page 5, 
they turn 1 page and are at the correct page. Return 1.
Function Description:
Complete the pageCount function in the editor below.
pageCount has the following parameter(s):
* int n: the number of pages in the book
* int p: the page number to turn to
Returns:
* int: the minimum number of pages to turn
Input Format:
The first line contains an integer n, the number of pages in the book.
The second line contains an integer, p, the page to turn to.
Constraints:
1 <= n <= 10^5
1 <= p <= n

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}

/*
 * Complete the 'pageCount' function below.
 *
 * The function is expected to return an INTEGER.
 * The function accepts following parameters:
 *  1. INTEGER n
 *  2. INTEGER p
 */

function pageCount(n, p) {
    // Write your code here
	// Turns from the front
    const fromFront = Math.floor(p / 2);
    // Turns from the back
    const fromBack = Math.floor(n / 2) - Math.floor(p / 2);
    // Return the minimum of the two
    return Math.min(fromFront, fromBack);

}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const n = parseInt(readLine().trim(), 10);

    const p = parseInt(readLine().trim(), 10);

    const result = pageCount(n, p);

    ws.write(result + '\n');

    ws.end();
}
--------------------------------------------------------------

Tower Breakers
Two players are playing a game of Tower Breakers! Player 1 always moves first, and both players always play 
optimally.The rules of the game are as follows:
* Initially there are n towers.
* Each tower is of height m.
* The players move in alternating turns.
* In each turn, a player can choose a tower of height x and reduce its height to y, where 1 <= y < x 
and y evenly divides x.
* If the current player is unable to make a move, they lose the game.
Given the values of n and m, determine which player will win. If the first player wins, return 1. Otherwise, return 2.
Example: 
n = 2
m = 6
There are 2 towers, each 6 units tall. Player 1 has a choice of two moves:
- remove 3 pieces from a tower to leave 3 as 6 modulo 3 = 0.
- remove 5 pieces to leave 1.
Let Player 1 remove 3. Now the towers are 3 and 6 units tall.
Player 2 matches the move. Now the towers are both 3 units tall.
Now Player 1 has only one move.
Player 1 removes 2 pieces leaving 1. Towers are 1 and 2 units tall.
Player 2 matches again. Towers are both 1 unit tall.
Player 1 has no move and loses. Return 2.
Function Description:
Complete the towerBreakers function in the editor below.
towerBreakers has the following paramter(s):
* int n: the number of towers
* int m: the height of each tower
Returns:
* int: the winner of the game
Input Format:
The first line contains a single integer t, the number of test cases.
Each of the next t lines describes a test case in the form of 2 space-separated integers, n and m.
Constraints:
1 <= t <= 100
1 <= n,m <= 10^6

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}

/*
 * Complete the 'towerBreakers' function below.
 *
 * The function is expected to return an INTEGER.
 * The function accepts following parameters:
 *  1. INTEGER n
 *  2. INTEGER m
 */

function towerBreakers(n, m) {
    // Write your code here
	if(m === 1) {
		return 2;
	} else if(n % 2 === 0) {
		return 2;
	} else {
		return 1;
	}
}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const t = parseInt(readLine().trim(), 10);

    for (let tItr = 0; tItr < t; tItr++) {
        const firstMultipleInput = readLine().replace(/\s+$/g, '').split(' ');

        const n = parseInt(firstMultipleInput[0], 10);

        const m = parseInt(firstMultipleInput[1], 10);

        const result = towerBreakers(n, m);

        ws.write(result + '\n');
    }

    ws.end();
}

-------------------------------------------------------------
Max Min
You will be given a list of integers, arr, and a single integer k. You must create an array of length k 
from elements of arr such that its unfairness is minimized. Call that array arr'. Unfairness of an array is calculated as
max(arr') - min(arr')
Where:
- max denotes the largest integer in arr'.
- min denotes the smallest integer in arr'.
Example:
arr = [1,4,7,2]
k = 2
Pick any two elements, say arr' = [4,7].
unfairness = max(4,7) - min(4,7) = 7 - 4 = 3
Testing for all pairs, the solution [1,2] provides the minimum unfairness.
Note: Integers in arr may not be unique.
Function Description:
Complete the maxMin function in the editor below.
maxMin has the following parameter(s):
* int k: the number of elements to select
* int arr[n]:: an array of integers
Returns:
* int: the minimum possible unfairness
Input Format:
The first line contains an integer n, the number of elements in array arr.
The second line contains an integer k.
Each of the next n lines contains an integer arr[i] where 0 <= i < n.
Constraints:
2 <= n <= 10^5
2 <= k <= n
0 <= arr[i] <= 10^9

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}

/*
 * Complete the 'maxMin' function below.
 *
 * The function is expected to return an INTEGER.
 * The function accepts following parameters:
 *  1. INTEGER k
 *  2. INTEGER_ARRAY arr
 */

function maxMin(k, arr) {
    // Write your code here
	arr.sort((a, b) => a - b);
	let minUnfairness = Infinity;
	for(let i = 0; i <= arr.length - k; i++) {
		let unfairness = arr[i + k - 1] - arr[i];
		if(unfairness < minUnfairness) {
			minUnfairness = unfairness;
		}
	}
	return minUnfairness;
}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const n = parseInt(readLine().trim(), 10);

    const k = parseInt(readLine().trim(), 10);

    let arr = [];

    for (let i = 0; i < n; i++) {
        const arrItem = parseInt(readLine().trim(), 10);
        arr.push(arrItem);
    }

    const result = maxMin(k, arr);

    ws.write(result + '\n');

    ws.end();
}

---------------------------------------------------------------------
Dynamic Array
Declare a 2-dimensional array, arr, of n empty arrays. All arrays are zero indexed.
Declare an integer, lastAnswer, and initialize it to 0.
There are 2 types of queries, given as an array of strings for you to parse:
1. Query: 1 x y
1.1. Let idx = (( x ^ lastAnswer) % n).
1.2. Append the integer y to arr[idx].
2. Query: 2 x y
2.1. Let idx = (( x ^ lastAnswer) % n).
2.2. Assign the value arr[idx][y % size(arr[idx])] to lastAnswer.
2.3. Store the new value of lastAnswer to an answers array.
Note: ^ is the bitwise XOR operation, which corresponds to the ^ operator in most languages. Learn more about it on Wikipedia. % is the modulo operator.
Finally, size(arr[idx]) is the number of elements in arr[idx]
Function Description:
Complete the dynamicArray function below.
dynamicArray has the following parameters:
- int n: the number of empty arrays to initialize in arr.
- string queries[q]: query strings that contain 3 space-separated integers.
Returns:
* int[]: the results of each type 2 query in the order they are presented
Input Format:
The first line contains two space-separated integers, n, the size of arr to create, and q, the number of queries, respectively.
Each of the q subsequent lines contains a query string, queries[i].
Constraints:
1 <= n,q <= 10^5
0 <= x,y <= 10^9
It is guaranteed that query type 2 will never query an empty array or index.


'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}

/*
 * Complete the 'dynamicArray' function below.
 *
 * The function is expected to return an INTEGER_ARRAY.
 * The function accepts following parameters:
 *  1. INTEGER n
 *  2. 2D_INTEGER_ARRAY queries
 */

function dynamicArray(n, queries) {
    // Write your code here
	const arr = Array.from({length: n}, () => []);
	let lastAnswer = 0;
	const answers = [];
	for(let i = 0; i < queries.length; i++) {
		const [type, x, y] = queries[i];
		const idx = (x ^ lastAnswer) % n;
		if(type === 1) {
			arr[idx].push(y);
		} else if(type === 2) {
			lastAnswer = arr[idx][y % arr[idx].length];
			answers.push(lastAnswer);
		}
	}
	return answers;
}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const firstMultipleInput = readLine().replace(/\s+$/g, '').split(' ');

    const n = parseInt(firstMultipleInput[0], 10);

    const q = parseInt(firstMultipleInput[1], 10);

    let queries = Array(q);

    for (let i = 0; i < q; i++) {
        queries[i] = readLine().replace(/\s+$/g, '').split(' ').map(queriesTemp => parseInt(queriesTemp, 10));
    }

    const result = dynamicArray(n, queries);

    ws.write(result.join('\n') + '\n');

    ws.end();
}

---------------------------------------------------------------------------------------
Running Time and Complexity
Task:
A prime is a natural number greater than 1 that has no positive divisors other than  and itself. 
Given a number, n, determine and print whether it is Prime or Not prime.
Note: If possible, try to come up with a O(sqrt of n) primality algorithm, 
or see what sort of optimizations you come up with for an O(n) algorithm. 
Input Format:
The first line contains an integer, T, the number of test cases.
Each of the T subsequent lines contains an integer, n, to be tested for primality.
Constraints:
1 <= T <= 30
1 <= n <= 2x10^9

function isPrime(n) {
    if (n <= 1) return false;
    if (n === 2) return true;
    if (n % 2 === 0) return false;
    const sqrtN = Math.sqrt(n);
    for (let i = 3; i <= sqrtN; i += 2) {
        if (n % i === 0) return false;
    }
    return true;
}
function processData(input) {
    //Enter your code here
	const lines = input.trim().split('\n');
	const T = parseInt(lines[0], 10);
	for(let i = 1; i <= T; i++) {
		const n = parseInt(lines[i], 10);
		console.log(isPrime(n) ? 'Prime' : 'Not prime');
	}
} 

process.stdin.resume();
process.stdin.setEncoding("ascii");
_input = "";
process.stdin.on("data", function (input) {
    _input += input;
});

process.stdin.on("end", function () {
   processData(_input);
});

-------------------------------------------------------------------------------------------

Grid Challenge
Given a square grid of characters in the range ascii[a-z], rearrange elements of each row alphabetically, ascending. 
Determine if the columns are also in ascending alphabetical order, top to bottom. Return YES if they are or NO if they are not.
Example:
grid = ['abc','ade','efg']
The grid is illustrated below.
a b c
a d e
e f g
The rows are already in alphabetical order. The columns a a e, b d f and c e g are also in alphabetical order, so the answer would be YES. 
Only elements within the same row can be rearranged. They cannot be moved to a different row.
Function Description:
Complete the gridChallenge function in the editor below.
gridChallenge has the following parameter(s):
* string grid[n]: an array of strings
Returns:
* string: either YES or NO
Input Format:
The first line contains t, the number of testcases.
Each of the next t sets of lines are described as follows:
- The first line contains n, the number of rows and columns in the grid.
- The next n lines contains a string of length n.
Constraints:
1 <= t <= 100
1 <= n <= 100
Each string consists of lowercase letters in the range ascii[a-z]

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}

/*
 * Complete the 'gridChallenge' function below.
 *
 * The function is expected to return a STRING.
 * The function accepts STRING_ARRAY grid as parameter.
 */

function gridChallenge(grid) {
    // Write your code here
	for(let i = 0; i < grid.length; i++) {
		grid[i] = grid[i].split('').sort().join('');
	}
	let n = grid.length;
	for(let col = 0; col < n; col++) {
		for(let row = 1; row < n; row++) {
			if(grid[row][col] < grid[row - 1][col]) {
				return "NO";
			}
		}
	}
	return "YES";
}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const t = parseInt(readLine().trim(), 10);

    for (let tItr = 0; tItr < t; tItr++) {
        const n = parseInt(readLine().trim(), 10);

        let grid = [];

        for (let i = 0; i < n; i++) {
            const gridItem = readLine();
            grid.push(gridItem);
        }

        const result = gridChallenge(grid);

        ws.write(result + '\n');
    }

    ws.end();
}

------------------------------------------------------------------------

Prime Dates
Given two dates each in the format dd-mm-yyyy, you have to find the number of lucky dates between them (inclusive). 
To see if a date is lucky,
* Firstly, sequentially concatinate the date, month and year, into a new integer x erasing the leading zeroes.
* Now if x is divisible by either 4 or 7, then we call the date a lucky date.
For example, let's take the date "02-08-2024". After concatinating the day, month and year, we get x = 2082024. 
As x is divisible by 4 so the date "02-08-2024" is called a lucky date.
Debug the given function findPrimeDates and/or other lines of code, to find the correct lucky dates from the given input.
Note: You can modify at most five lines in the given code and you cannot add or remove lines to the code.
To restore the original code, click on the icon to the right of the language selector.
Input Format:
The only line of the input contains two strings u and v denoting the two dates following the format dd-mm-yyyy. 
Consider, d is the day number, m is the month number and y is the year number.
Note: Here m = 01 means January, m = 02 means February, m = 03 means March and so on and all the dates 
follow the standard structure of English calender including the leap year.
Constraints:
1 <= d1,d2 <= 31
1 <= m1,m2 <= 12
1000 <= y1 <= y2 <= 9999

function processData(input) {
    //Enter your code here
function isLuckyDate(d, m, y) {
        // Remove leading zeroes by converting to Number, then concatenate
        let x = Number(d) + '' + Number(m) + '' + Number(y);
        x = parseInt(x, 10);
        return (x % 4 === 0 || x % 7 === 0);
    }

    function nextDate(d, m, y) {
        const daysInMonth = [31, (y % 4 === 0 && (y % 100 !== 0 || y % 400 === 0)) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        d++;
        if (d > daysInMonth[m - 1]) {
            d = 1;
            m++;
            if (m > 12) {
                m = 1;
                y++;
            }
        }
        return [d, m, y];
    }

    let [u, v] = input.trim().split(' ');
    let [d1, m1, y1] = u.split('-').map(Number);
    let [d2, m2, y2] = v.split('-').map(Number);

    let count = 0;
    while (true) {
        if (isLuckyDate(d1, m1, y1)) count++;
        if (d1 === d2 && m1 === m2 && y1 === y2) break;
        [d1, m1, y1] = nextDate(d1, m1, y1);
    }
    console.log(count);
	
} 

process.stdin.resume();
process.stdin.setEncoding("ascii");
_input = "";
process.stdin.on("data", function (input) {
    _input += input;
});

process.stdin.on("end", function () {
   processData(_input);
});

---------------------------------------------------------------------

Watson gives Sherlock an array of integers. His challenge is to find an element of the array such 
that the sum of all elements to the left is equal to the sum of all elements to the right.
Example:
arr = [5,6,8,11]
8 is between two subarrays that sum to 11.
arr =[1]
The answer is [1] since left and right sum to 0.
You will be given arrays of integers and must determine whether there is an element that meets the criterion. 
If there is, return YES. Otherwise, return NO.
Function Description:
Complete the balancedSums function in the editor below.
balancedSums has the following parameter(s):
* int arr[n]: an array of integers
Returns:
* string: either YES or NO
Input Format:
The first line contains T, the number of test cases.
The next T pairs of lines each represent a test case.
- The first line contains n, the number of elements in the array arr.
- The second line contains n space-separated integers arr[i] where 0 <= i < n.
Constraints:
1 <= T <= 10
1 <= n <= 10^5
1 <= arr[i] <= 2x10^4
0 <= i < n

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}

/*
 * Complete the 'balancedSums' function below.
 *
 * The function is expected to return a STRING.
 * The function accepts INTEGER_ARRAY arr as parameter.
 */

function balancedSums(arr) {
    // Write your code here
	let totalSum = arr.reduce((a, b) => a + b, 0);
	let leftSum = 0;
	for(let i = 0; i < arr.length; i++) {
		if(leftSum === totalSum - leftSum - arr[i]) {
			return "YES";
		}
		leftSum += arr[i];
	}
	return "NO";
}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const T = parseInt(readLine().trim(), 10);

    for (let TItr = 0; TItr < T; TItr++) {
        const n = parseInt(readLine().trim(), 10);

        const arr = readLine().replace(/\s+$/g, '').split(' ').map(arrTemp => parseInt(arrTemp, 10));

        const result = balancedSums(arr);

        ws.write(result + '\n');
    }

    ws.end();
}

----------------------------------------------------------------------------------

Recursive Digit Sum
We define super digit of an integer  using the following rules:
Given an integer, we need to find the super digit of the integer.
* If x has only 1 digit, then its super digit is x.
* Otherwise, the super digit of x is equal to the super digit of the sum of the digits of x.
For example, the super digit of 9875 will be calculated as:

	super_digit(9875)   	9+8+7+5 = 29 
	super_digit(29) 	2 + 9 = 11
	super_digit(11)		1 + 1 = 2
	super_digit(2)		= 2  
Example:
n =' 9875'
k = 4
The number p is created by concatenating the string  n k times so the initial p = 9875987598759875.

    superDigit(p) = superDigit(9875987598759875)
                  9+8+7+5+9+8+7+5+9+8+7+5+9+8+7+5 = 116
    superDigit(p) = superDigit(116)
                  1+1+6 = 8
    superDigit(p) = superDigit(8)
All of the digits of p sum to 116. The digits of 116 sum to 8. 8 is only one digit, so it is the super digit.
Function Description:
Complete the function superDigit in the editor below. It must return the calculated super digit as an integer.
superDigit has the following parameter(s):
* string n: a string representation of an integer.
* int k: the times to concatenate n to make p.
Returns:
* int: the super digit of n repeated k times.
Input Format:
The first line contains two space separated integers, n and k.
Constraints:
1 <= n < 10^100000
1 <= k <= 10^5

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}

/*
 * Complete the 'superDigit' function below.
 *
 * The function is expected to return an INTEGER.
 * The function accepts following parameters:
 *  1. STRING n
 *  2. INTEGER k
 */

function superDigit(n, k) {
    // Write your code here
	function helper(str) {
		if(str.length === 1) return parseInt(str, 10);
		let sum = 0;
		for(let c of str) sum += parseInt(c, 10);
		return helper(sum.toString());
		}
	let initialSum = 0;
	for(let c of n) initialSum += parseInt(c, 10);
	let p = (initialSum * k).toString();
	return helper(p);
}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const firstMultipleInput = readLine().replace(/\s+$/g, '').split(' ');

    const n = firstMultipleInput[0];

    const k = parseInt(firstMultipleInput[1], 10);

    const result = superDigit(n, k);

    ws.write(result + '\n');

    ws.end();
}
-----------------------------------------------------------------------------

Counter Game
Louise and Richard have developed a numbers game. They pick a number and check to see if it is a power of 2. 
If it is, they divide it by 2. If not, they reduce it by the next lower number which is a power of 2. 
Whoever reduces the number to 1 wins the game. Louise always starts.
Given an initial value, determine who wins the game.
Example:
n = 132
It's Louise's turn first. She determines that 132 is not a power of 2. The next lower power of 2 is 128, 
so she subtracts that from 132 and passes 4 to Richard. 4 is a power of 2, so Richard divides it by 2 and passes 2 to Louise. 
Likewise, 2 is a power so she divides it by 2 and reaches 1. She wins the game.
Update If they initially set counter to 1, Richard wins. Louise cannot make a move so she loses.
Function Description:
Complete the counterGame function in the editor below.
counterGame has the following parameter(s):
* int n: the initial game counter value
Returns:
* string: either Richard or Louise
Input Format:
The first line contains an integer t, the number of testcases.
Each of the next t lines contains an integer n, the initial value for each game.
Constraints:
1 <= t <= 10
1 <= n <= 2^64 - 1

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}

/*
 * Complete the 'counterGame' function below.
 *
 * The function is expected to return a STRING.
 * The function accepts LONG_INTEGER n as parameter.
 */

function counterGame(n) {
    // Write your code here
	n = BigInt(n);
	let moves = 0;
	while(n > 1n) {
		if((n & (n - 1n)) === 0n) {
			n = n / 2n;
	} else {
            // Reduce by the largest power of 2 less than n
            let p = 1n;
            while (p * 2n < n) {
                p *= 2n;
            }
            n -= p;
        }
        moves++;
    }
    return (moves % 2 === 0) ? "Javor" : "Pepa";
}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const t = parseInt(readLine().trim(), 10);

    for (let tItr = 0; tItr < t; tItr++) {
        const n = parseInt(readLine().trim(), 10);

        const result = counterGame(n);

        ws.write(result + '\n');
    }

    ws.end();
}

-------------------------------------------------------------------------------------



























































