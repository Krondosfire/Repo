Lego Blocks
You have an infinite number of 4 types of lego blocks of sizes given as (depth x height x width):

d	h	w
1	1	1
1	1	2
1	1	3
1	1	4
Using these blocks, you want to make a wall of height n and width m. Features of the wall are:
- The wall should not have any holes in it.
- The wall you build should be one solid structure, so there should not be a straight vertical break across all rows of bricks.
- The bricks must be laid horizontally.
How many ways can the wall be built?
Example:
n = 2
m = 3
The height is 2 and the width is 3.
There are 9 valid permutations in all.
Function Description:
Complete the legoBlocks function in the editor below.
legoBlocks has the following parameter(s):
* int n: the height of the wall
* int m: the width of the wall
Returns:
- int: the number of valid wall formations modulo 
Input Format:
The first line contains the number of test cases t.
Each of the next t lines contains two space-separated integers n and m.
Constraints:
1 <= t <= 100
1 <= n,m <= 1000

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}

/*
 * Complete the 'legoBlocks' function below.
 *
 * The function is expected to return an INTEGER.
 * The function accepts following parameters:
 *  1. INTEGER n
 *  2. INTEGER m
 */
const MOD = 1000000007;
const maxM = 1000;
// Precompute T_arr for widths 0 to maxM
const T_arr = new Array(maxM + 1).fill(0n);
T_arr[0] = 1n;
for(let i = 1; i < maxM; i++) {
	T_arr[i] = 0n;
	if(i >= 1) T_arr[i] = (T_arr[i] + T_arr[i - 1]) % MOD;
	if(i >= 2) T_arr[i] = (T_arr[i] + T_arr[i - 2]) % MOD;
	if(i >= 3) T_arr[i] = (T_arr[i] + T_arr[i - 3]) % MOD;
	if(i >= 4) T_arr[i] = (T_arr[i] + T_arr[i - 4]) % MOD;
}

function modPowBigInt(base, exponent, modulus) {
	let result = 1n;
	base = base % modulus;
	
	while(exponent > 0n) {
		if(exponent % 2n === 1n) {
			result = (result * base) % modulus;
		}
		exponent = exponent >> 1n;
		base = (base * base) % modulus;
		
	}
	return result;
}

function legoBlocks(n, m) {
    // Write your code here
	const n_big = BigInt(n);
	const U = new Array(m + 1).fill(0n);
	for(let i = 1; i <= m; i++) {
		U[i] = modPowBigInt(T_arr[i], n_big, MOD);
	}
	const G = new Array(m + 1).fill(0n);
	G[0] = 1n;
	for(let i = 1; i <= m; i++) {
		let sum = 0n;
		for(let j = 1; j < i; j++) {
			const product = (G[j] * U[i - j]) % MOD;
			sum = (sum + product) % MOD;
			
		}
		G[i] = (U[i] - sum + MOD) % MOD;
	}
	return Number(G[m] % MOD);
	
}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const t = parseInt(readLine().trim(), 10);

    for (let tItr = 0; tItr < t; tItr++) {
        const firstMultipleInput = readLine().replace(/\s+$/g, '').split(' ');

        const n = parseInt(firstMultipleInput[0], 10);

        const m = parseInt(firstMultipleInput[1], 10);

        const result = legoBlocks(n, m);

        ws.write(result + '\n');
    }

    ws.end();
}
--------------------------------------------------------------------------
QHEAP1
This question is designed to help you get a better understanding of basic heap operations.
There are 3 types of query:
* "1 v " - Add an element v to the heap.
* "2 v " - Delete the element v from the heap.
* "3" - Print the minimum of all the elements in the heap.
NOTE: It is guaranteed that the element to be deleted will be there in the heap. 
Also, at any instant, only distinct elements will be in the heap.
Input Format:
The first line contains the number of queries, Q.
Each of the next Q lines contains one of the 3 types of query.
Constraints:
1 <= Q <= 10^5
-10^9 <= v <= 10^9

function processData(input) {
    const lines = input.trim().split('\n');
    const Q = parseInt(lines[0]);
    const heap = [];
    const valueToIndex = new Map(); // value -> index in heap

    function swap(i, j) {
        [heap[i], heap[j]] = [heap[j], heap[i]];
        valueToIndex.set(heap[i], i);
        valueToIndex.set(heap[j], j);
    }

    function heapifyUp(index) {
        while (index > 0) {
            let parent = Math.floor((index - 1) / 2);
            if (heap[parent] > heap[index]) {
                swap(parent, index);
                index = parent;
            } else break;
        }
    }

    function heapifyDown(index) {
        let left, right, smallest;
        while (true) {
            left = 2 * index + 1;
            right = 2 * index + 2;
            smallest = index;
            if (left < heap.length && heap[left] < heap[smallest]) smallest = left;
            if (right < heap.length && heap[right] < heap[smallest]) smallest = right;
            if (smallest !== index) {
                swap(index, smallest);
                index = smallest;
            } else break;
        }
    }

    for (let i = 1; i <= Q; i++) {
        const parts = lines[i].trim().split(' ');
        const type = parts[0];
        if (type === '1') {
            // Insert
            const v = parseInt(parts[1]);
            heap.push(v);
            valueToIndex.set(v, heap.length - 1);
            heapifyUp(heap.length - 1);
        } else if (type === '2') {
            // Delete
            const v = parseInt(parts[1]);
            const idx = valueToIndex.get(v);
            const last = heap.length - 1;
            if (idx !== last) {
                swap(idx, last);
            }
            heap.pop();
            valueToIndex.delete(v);
            if (idx < heap.length) {
                heapifyUp(idx);
                heapifyDown(idx);
            }
        } else if (type === '3') {
            // Print min
            console.log(heap[0]);
        }
    }
}


process.stdin.resume();
process.stdin.setEncoding("ascii");
_input = "";
process.stdin.on("data", function (input) {
    _input += input;
});

process.stdin.on("end", function () {
   processData(_input);
});
--------------------------------------------------------------------

Jesse and Cookies
Jesse loves cookies and wants the sweetness of some cookies to be greater than value k. 
To do this, two cookies with the least sweetness are repeatedly mixed. 
This creates a special combined cookie with:
sweetness = (1 X Least sweet cookie + 2 X 2nd least sweet cookie).
This occurs until all the cookies have a sweetness >= k.
Given the sweetness of a number of cookies, determine the minimum number of operations required. 
If it is not possible, return -1.
Example:
k = 9
A = [2,7,3,6,4,6]
The smallest values are 2, 3.
Remove them then return 2 + 2 X 3 = 8 to the array. Now A = [8,7,6,4,6].
Remove 4,6 and return 4 + 6 X 2 = 16 to the array. Now A = [16,8,7,6].
Remove 6,7, return 6 + 2 X 7 = 20 and A = [20,16,8,7].
Finally, remove 8,7 and return 7 + 2 X 8 = 23 to A. Now A = [23,20,16].
All values are >= k=9 so the process stops after 4 iterations. Return 4.
Function Description:
Complete the cookies function in the editor below.
cookies has the following parameters:
* int k: the threshold value
* int A[n]: an array of sweetness values
Returns:
* int: the number of iterations required or 
Input Format:
The first line has two space-separated integers, n and k, the size of A[] and 
the minimum required sweetness respectively.
The next line contains n space-separated integers, A[i].
Constraints:
1 <= n < 10^6
0 <= k <= 10^9
0 <= A[i] <= 10^6

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}

/*
 * Complete the 'cookies' function below.
 *
 * The function is expected to return an INTEGER.
 * The function accepts following parameters:
 *  1. INTEGER k
 *  2. INTEGER_ARRAY A
 */

class MinHeap {
    constructor(data = []) {
        this.heap = data;
        if (this.heap.length > 0) {
            this.buildHeap();
        }
    }

    buildHeap() {
        for (let i = Math.floor(this.heap.length / 2) - 1; i >= 0; i--) {
            this.heapifyDown(i);
        }
    }

    size() {
        return this.heap.length;
    }

    peek() {
        return this.heap.length > 0 ? this.heap[0] : undefined;
    }

    insert(value) {
        this.heap.push(value);
        this.heapifyUp(this.heap.length - 1);
    }

    extractMin() {
        if (this.heap.length === 0) return undefined;
        const min = this.heap[0];
        const last = this.heap.pop();
        if (this.heap.length > 0) {
            this.heap[0] = last;
            this.heapifyDown(0);
        }
        return min;
    }

    heapifyUp(index) {
        let current = index;
        while (current > 0) {
            const parent = Math.floor((current - 1) / 2);
            if (this.heap[parent] > this.heap[current]) {
                [this.heap[parent], this.heap[current]] = [this.heap[current], this.heap[parent]];
                current = parent;
            } else {
                break;
            }
        }
    }

    heapifyDown(index) {
        let current = index;
        const n = this.heap.length;
        while (true) {
            const left = 2 * current + 1;
            const right = 2 * current + 2;
            let smallest = current;

            if (left < n && this.heap[left] < this.heap[smallest]) {
                smallest = left;
            }
            if (right < n && this.heap[right] < this.heap[smallest]) {
                smallest = right;
            }

            if (smallest !== current) {
                [this.heap[current], this.heap[smallest]] = [this.heap[smallest], this.heap[current]];
                current = smallest;
            } else {
                break;
            }
        }
    }
}

function cookies(k, A) {
    const heap = new MinHeap(A);
    let ops = 0;

    while (heap.size() >= 2 && heap.peek() < k) {
        const a = heap.extractMin();
        const b = heap.extractMin();
        const newCookie = a + 2 * b;
        heap.insert(newCookie);
        ops++;
    }

    if (heap.peek() < k) {
        return -1;
    } else {
        return ops;
    }
}

function processData(input) {
    const lines = input.trim().split('\n');
    const firstLine = lines[0].split(' ');
    const n = parseInt(firstLine[0]);
    const k = parseInt(firstLine[1]);
    const A = lines[1].split(' ').map(Number);
    console.log(cookies(k, A));
}


function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const firstMultipleInput = readLine().replace(/\s+$/g, '').split(' ');

    const n = parseInt(firstMultipleInput[0], 10);

    const k = parseInt(firstMultipleInput[1], 10);

    const A = readLine().replace(/\s+$/g, '').split(' ').map(ATemp => parseInt(ATemp, 10));

    const result = cookies(k, A);

    ws.write(result + '\n');

    ws.end();
}
------------------------------------------------------------------------------
Hackerland Radio Transmitters
Hackerland is a one-dimensional city with houses aligned at integral locations along a road. 
The Mayor wants to install radio transmitters on the roofs of the city's houses. 
Each transmitter has a fixed range meaning it can transmit a signal to all houses within that number of units distance away.
Given a map of Hackerland and the transmission range, determine the minimum number of transmitters so that every 
house is within range of at least one transmitter. Each transmitter must be installed on top of an existing house.
Example:
x = [1,2,3,5,9]
k = 1
3 antennae at houses 2 and 5 and 9 provide complete coverage. There is no house at location 7 to cover both 5 and 9. 
Ranges of coverage, are [1,2,3], [5], and [9].
Function Description:
Complete the hackerlandRadioTransmitters function in the editor below.
hackerlandRadioTransmitters has the following parameter(s):
* int x[n]: the locations of houses
* int k: the effective range of a transmitter
Returns:
* int: the minimum number of transmitters to install
Input Format:
The first line contains two space-separated integers n and k, the number of houses in Hackerland and the range of each transmitter.
The second line contains n space-separated integers describing the respective locations of each house x[i].
Constraints:
1 <= n,k <= 10^5
1 <= x[i] <= 10^5
There may be more than one house at the same location.

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}

/*
 * Complete the 'hackerlandRadioTransmitters' function below.
 *
 * The function is expected to return an INTEGER.
 * The function accepts following parameters:
 *  1. INTEGER_ARRAY x
 *  2. INTEGER k
 */

function hackerlandRadioTransmitters(x, k) {
    // Write your code here
	if (x.length === 0) return 0;
    
    	const houses = [...new Set(x)].sort((a, b) => a - b);
    	const n = houses.length;
    	let count = 0;
    	let i = 0;
    
    	while (i < n) {
        	count++;
        	let j = i;
        	while (j < n && houses[j] <= houses[i] + k) {
            		j++;
        	}
        	const transmitterLoc = houses[j - 1];
        
        	while (i < n && houses[i] <= transmitterLoc + k) {
            		i++;
        	}
    	}
    
    	return count;
}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const firstMultipleInput = readLine().replace(/\s+$/g, '').split(' ');

    const n = parseInt(firstMultipleInput[0], 10);

    const k = parseInt(firstMultipleInput[1], 10);

    const x = readLine().replace(/\s+$/g, '').split(' ').map(xTemp => parseInt(xTemp, 10));

    const result = hackerlandRadioTransmitters(x, k);

    ws.write(result + '\n');

    ws.end();
}
-------------------------------------------------------------------------------
Queries with Fixed Length
Consider an n-integer sequence, A = {a(0), a(1), ...,a(n-1)}. We perform a query on A by using an integer, d, 
to calculate the result of the following expression:
min{max(a(j))} where min --> 0<= i <= n - d; max(a(j)) --> i <= j < i + d
In other words, if we let m(i) = max(a(i), a(i+1), a(i+2), ...,a(i+d-1)), then you need to calculate min(m(0), m(1), ...,m(n-d)).
Given arr and q queries, return a list of answers to each query.
Example:
arr = [2,3,4,5,6]
queries = [2,3]
The first query uses all of the subarrays of length 2: [2,3],[3,4],[4,5],[5,6]. 
The maxima of the subarrays are [3,4,5,6]. The minimum of these is 3.
The second query uses all of the subarrays of length 3: [2,3,4],[3,4,5],[4,5,6]. 
The maxima of the subarrays are [4,5,6]. The minimum of these is 4.
Return [3,4].
Function Description:
Complete the solve function below.
solve has the following parameter(s):
* int arr[n]: an array of integers
* int queries[q]: the lengths of subarrays to query
Returns:
* int[q]: the answers to each query
Input Format:
The first line consists of two space-separated integers, n and q.
The second line consists of n space-separated integers, the elements of arr.
Each of the q subsequent lines contains a single integer denoting the value of d for that query.
Constraints:
1 <= n <= 10^5
0 <= arr[i] < 10^6
1 <= q <= 100
1 <= d <= n

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}

/*
 * Complete the 'solve' function below.
 *
 * The function is expected to return an INTEGER_ARRAY.
 * The function accepts following parameters:
 *  1. INTEGER_ARRAY arr
 *  2. INTEGER_ARRAY queries
 */

function solve(arr, queries) {
    const n = arr.length;
    const results = [];
    for (const d of queries) {
        // Deque for sliding window max
        const deque = [];
        let minOfMax = Infinity;

        for (let i = 0; i < n; i++) {
            // Remove elements out of window
            while (deque.length && deque[0] <= i - d) {
                deque.shift();
            }
            // Remove smaller elements from the back
            while (deque.length && arr[deque[deque.length - 1]] <= arr[i]) {
                deque.pop();
            }
            deque.push(i);

            // Window is ready
            if (i >= d - 1) {
                minOfMax = Math.min(minOfMax, arr[deque[0]]);
            }
        }
        results.push(minOfMax);
    }
    return results;
}


function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const firstMultipleInput = readLine().replace(/\s+$/g, '').split(' ');

    const n = parseInt(firstMultipleInput[0], 10);

    const q = parseInt(firstMultipleInput[1], 10);

    const arr = readLine().replace(/\s+$/g, '').split(' ').map(arrTemp => parseInt(arrTemp, 10));

    let queries = [];

    for (let i = 0; i < q; i++) {
        const queriesItem = parseInt(readLine().trim(), 10);
        queries.push(queriesItem);
    }

    const result = solve(arr, queries);

    ws.write(result.join('\n') + '\n');

    ws.end();
}
---------------------------------------------------------------------------------------------------

Array Manipulation
Starting with a 1-indexed array of zeros and a list of operations, for each operation add a value to e
ach the array element between two given indices, inclusive. Once all operations have been performed, 
return the maximum value in the array.
Example:
n = 10
queries = [[1,5,3],[4,8,7],[6,9,1]]
Queries are interpreted as follows:

    a b k
    1 5 3
    4 8 7
    6 9 1
Add the values of k between the indices a and b inclusive:
index->	 1 2 3  4  5 6 7 8 9 10
	[0,0,0, 0, 0,0,0,0,0, 0]
	[3,3,3, 3, 3,0,0,0,0, 0]
	[3,3,3,10,10,7,7,7,0, 0]
	[3,3,3,10,10,8,8,8,1, 0]
The largest value is 10 after all operations are performed.
Function Description:
Complete the function arrayManipulation in the editor below.
arrayManipulation has the following parameters:
* int n - the number of elements in the array
* int queries[q][3] - a two dimensional array of queries where each queries[i] contains three integers, a, b, and k.
Returns:
* int - the maximum value in the resultant array
Input Format:
The first line contains two space-separated integers n and m, the size of the array and the number of operations.
Each of the next m lines contains three space-separated integers a, b and k, the left index, right index and summand.
Constraints:
3 <= n <= 10^7
1 <= m <= 2 x 10^5
1 <= a <= b <= n
0 <= k <= 10^9

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}

/*
 * Complete the 'arrayManipulation' function below.
 *
 * The function is expected to return a LONG_INTEGER.
 * The function accepts following parameters:
 *  1. INTEGER n
 *  2. 2D_INTEGER_ARRAY queries
 */

function arrayManipulation(n, queries) {
    const diff = new Array(n + 2).fill(0);
    
    for (const [a, b, k] of queries) {
        diff[a] += k;
        if (b + 1 <= n) {
            diff[b + 1] -= k;
        }
    }
    
    let max = 0;
    let current = 0;
    for (let i = 1; i <= n; i++) {
        current += diff[i];
        if (current > max) {
            max = current;
        }
    }
    
    return max;
}


function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const firstMultipleInput = readLine().replace(/\s+$/g, '').split(' ');

    const n = parseInt(firstMultipleInput[0], 10);

    const m = parseInt(firstMultipleInput[1], 10);

    let queries = Array(m);

    for (let i = 0; i < m; i++) {
        queries[i] = readLine().replace(/\s+$/g, '').split(' ').map(queriesTemp => parseInt(queriesTemp, 10));
    }

    const result = arrayManipulation(n, queries);

    ws.write(result + '\n');

    ws.end();
}
-------------------------------------------------------------------------------------------------------

Highest Value Palindrome
Palindromes are strings that read the same from the left or right, for example madam or 0110.
You will be given a string representation of a number and a maximum number of changes you can make. 
Alter the string, one digit at a time, to create the string representation of the largest number possible given the limit to the number of changes. 
The length of the string may not be altered, so you must consider 's left of all higher digits in your tests. For example 0110 is valid, 0011 is not.
Given a string representing the starting number, and a maximum number of changes allowed, create the largest palindromic string of digits possible or 
the string '-1' if it is not possible to create a palindrome under the contstraints.
Example:
s = '1231'
k = 3
Make 3 replacements to get '9339'.
s = '12321'
k = 1
Make 1 replacement to get '12921'.
Function Description:
Complete the highestValuePalindrome function in the editor below.
highestValuePalindrome has the following parameter(s):
string s: a string representation of an integer
* int n: the length of the integer string
* int k: the maximum number of changes allowed
Returns:
* string: a string representation of the highest value achievable or -1
Input Format:
The first line contains two space-separated integers, n and k, the number of digits in the number and the maximum number of changes allowed.
The second line contains an n-digit string of numbers.
Constraints:
0 <= n <= 10^5
0 <= k <= 10^5
Each character i in the number is an integer where 0 <= i <= 9

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}

/*
 * Complete the 'highestValuePalindrome' function below.
 *
 * The function is expected to return a STRING.
 * The function accepts following parameters:
 *  1. STRING s
 *  2. INTEGER n
 *  3. INTEGER k
 */

function highestValuePalindrome(s, n, k) {
    // Write your code here
	let arr = s.split('');
    let changed = new Array(n).fill(false);
    let l = 0, r = n - 1;
    let changes = 0;

    // First pass: make it a palindrome with minimal changes
    while (l < r) {
        if (arr[l] !== arr[r]) {
            let maxDigit = arr[l] > arr[r] ? arr[l] : arr[r];
            arr[l] = arr[r] = maxDigit;
            changed[l] = changed[r] = true;
            changes++;
        }
        l++; r--;
    }

    if (changes > k) return '-1';

    // Second pass: maximize palindrome value
    l = 0; r = n - 1;
    let remaining = k - changes;
    while (l <= r) {
        if (l === r) {
            // Middle digit in odd-length string
            if (remaining > 0 && arr[l] !== '9') {
                arr[l] = '9';
            }
        } else {
            if (arr[l] !== '9') {
                // If already changed, only 1 more change needed
                if (changed[l] || changed[r]) {
                    if (remaining > 0) {
                        arr[l] = arr[r] = '9';
                        remaining--;
                    }
                } else {
                    // If not changed, need 2 changes
                    if (remaining > 1) {
                        arr[l] = arr[r] = '9';
                        remaining -= 2;
                    }
                }
            }
        }
        l++; r--;
    }

    return arr.join('');

}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const firstMultipleInput = readLine().replace(/\s+$/g, '').split(' ');

    const n = parseInt(firstMultipleInput[0], 10);

    const k = parseInt(firstMultipleInput[1], 10);

    const s = readLine();

    const result = highestValuePalindrome(s, n, k);

    ws.write(result + '\n');

    ws.end();
}
--------------------------------------------------------------------------------------------------------------------------

Lili's Homework
Whenever George asks Lily to hang out, she's busy doing homework. George wants to help her finish it faster, 
but he's in over his head! Can you help George understand Lily's homework so she can hang out with him?
Consider an array of n distinct integers, arr = [a[0],a[1],...,a[n-1]]. George can swap any two elements of 
the array any number of times. An array is beautiful if the sum of |arr[i] - arr[i-1]| among 0 < i < n is minimal.
Given the array arr, determine and return the minimum number of swaps that should be performed in order to make the array beautiful.
Example:
arr = [7,15,12,3]
One minimal array is [3,7,12,15]. To get there, George performed the following swaps:

    Swap      Result
          [7, 15, 12, 3]
    3 7   [3, 15, 12, 7]
    7 15  [3, 7, 12, 15]
   
It took 2 swaps to make the array beautiful. This is minimal among the choices of beautiful arrays possible.
Function Description:
Complete the lilysHomework function in the editor below.
lilysHomework has the following parameter(s):
* int arr[n]: an integer array
Returns:
* int: the minimum number of swaps required
Input Format:
The first line contains a single integer, n, the number of elements in arr. The second line contains n space-separated integers, arr[i].
Constraints:
1 <= n <= 10^5
1 <= arr[i] <= 2x10^9

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}

/*
 * Complete the 'lilysHomework' function below.
 *
 * The function is expected to return an INTEGER.
 * The function accepts INTEGER_ARRAY arr as parameter.
 */

function lilysHomework(arr) {
    function minSwaps(targetArr) {
        const n = arr.length;
        const arrCopy = arr.slice();
        const valueToIndex = new Map();
        for (let i = 0; i < n; i++) valueToIndex.set(arrCopy[i], i);
        let swaps = 0;
        for (let i = 0; i < n; i++) {
            if (arrCopy[i] !== targetArr[i]) {
                swaps++;
                // Swap arrCopy[i] with the correct value's position
                const toSwapIdx = valueToIndex.get(targetArr[i]);
                // Update map before swap
                valueToIndex.set(arrCopy[i], toSwapIdx);
                valueToIndex.set(arrCopy[toSwapIdx], i);
                // Swap
                [arrCopy[i], arrCopy[toSwapIdx]] = [arrCopy[toSwapIdx], arrCopy[i]];
            }
        }
        return swaps;
    }
    const sortedAsc = [...arr].sort((a, b) => a - b);
    const sortedDesc = [...arr].sort((a, b) => b - a);
    return Math.min(minSwaps(sortedAsc), minSwaps(sortedDesc));
}


function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const n = parseInt(readLine().trim(), 10);

    const arr = readLine().replace(/\s+$/g, '').split(' ').map(arrTemp => parseInt(arrTemp, 10));

    const result = lilysHomework(arr);

    ws.write(result + '\n');

    ws.end();
}
-----------------------------------------------------------------------------------------------------------
Tree: Preorder Traversal
Complete the preOrder function in the editor below, which has 1 parameter: a pointer to the root of a binary tree. 
It must print the values in the tree's preorder traversal as a single line of space-separated values.
Input Format:
Our test code passes the root node of a binary tree to the preOrder function.
Constraints:
1 <= Nodes in the tree <= 500
Output Format:
Print the tree's preorder traversal as a single line of space-separated values.
Sample Input:

     1
      \
       2
        \
         5
        /  \
       3    6
        \
         4  
Sample Output:
1 2 5 3 4 6 
Explanation:
The preorder traversal of the binary tree is printed.

var Tree = function() {
    this.root = null;
}

Tree.prototype.insert = function(node, data) {
    if (node == null){
    	node = new Node(data);
    }
 	else if (data < node.data){
        node.left  = this.insert(node.left, data);
    }
    else{
        node.right = this.insert(node.right, data);   
    }

    return node;
}

var Node = function(data) {
    this.data = data;
    this.left = null;
    this.right = null;
}

/* head ends */

/*
    Node is defined as
    var Node = function(data) {
        this.data = data;
        this.left = null;
        this.right = null;
    }
*/

// This is a "method-only" submission.
// You only need to complete this method.

function preOrder(root) {
	if(root == null) return;
	process.stdout.write(root.data + " ");
	preOrder(root.left);
	preOrder(root.right);
}

/* tail begins */

process.stdin.resume();
process.stdin.setEncoding('ascii');

var _stdin = "";
var _stdin_array = "";
var _currentline = 0;

process.stdin.on('data', function(data) {
    _stdin += data;
});

process.stdin.on('end', function() {
    _stdin_array = _stdin.split("\n");
    solution();
});

function readLine() {
    return _stdin_array[_currentline++];
}

function solution() {

    var tree = new Tree();
    var n = parseInt(readLine());
    var m = readLine().split(" ").map(Number);
    for (var i=0; i<n; i++) {
        tree.root = tree.insert(tree.root, m[i]);
    }

    preOrder(tree.root);
}
-----------------------------------------------------------------------------------
Tree: Huffman Decoding
Huffman coding assigns variable length codewords to fixed length input characters based on their frequencies. 
More frequent characters are assigned shorter codewords and less frequent characters are assigned longer codewords. 
All edges along the path to a character contain a code digit. If they are on the left side of the tree, they will be a 0 (zero). 
If on the right, they'll be a 1 (one). Only the leaves will contain a letter and its frequency count. 
All other nodes will contain a null instead of a character, and the count of the frequency of all of it and its descendant characters.
For instance, consider the string ABRACADABRA. There are a total of 11 characters in the string. 
This number should match the count in the ultimately determined root of the tree. Our frequencies are A=5, B=2, R=2, C=1 and D=1. 
The two smallest frequencies are for C and D, both equal to 1, so we'll create a tree with them. 
The root node will contain the sum of the counts of its descendants, in this case 1+1=2. 
The left node will be the first character encountered, C, and the right will contain D. Next we have 3 items with a character count of 2: 
the tree we just created, the character B and the character R. The tree came first, so it will go on the left of our new root node.  
B will go on the right. Repeat until the tree is complete, then fill in the 1's and 0's for the edges. The finished graph looks like:
     phi
    0/\1
  A,5  phi,6
      0/\1
    R,2  phi,4
       0/\1
     phi2 B,2
     0/\1
    C,1 D,1
Input characters are only present in the leaves. Internal nodes have a character value of ϕ (NULL). We can determine that our values for characters are:

A - 0
B - 111
C - 1100
D - 1101
R - 10
Our Huffman encoded string is:

A B    R  A C     A D     A B    R  A
0 111 10 0 1100 0 1101 0 111 10 0
or
01111001100011010111100
To avoid ambiguity, Huffman encoding is a prefix free encoding technique. No codeword appears as a prefix of any other codeword.
To decode the encoded string, follow the zeros and ones to a leaf and return the character there.
You are given pointer to the root of the Huffman tree and a binary coded string to decode. You need to print the decoded string.
Function Description:
Complete the function decode_huff in the editor below. It must return the decoded string.
decode_huff has the following parameters:
* root: a reference to the root node of the Huffman tree
* s: a Huffman encoded string
Input Format:
There is one line of input containing the plain string, s. Background code creates the Huffman tree then 
passes the head node and the encoded string to the function.
Constraints:
1 <= |s| <= 25

function decodeHuff(root, s) {
    let result = '';
    let node = root;
    for (let i = 0; i < s.length; i++) {
        node = (s[i] === '0') ? node.left : node.right;
        if (node.left === null && node.right === null) {
            result += node.data;
            node = root;
        }
    }
    console.log(result);
}
function processData(input) {
    //Enter your code here
	//decodeHuff(root, s);
	
} 

process.stdin.resume();
process.stdin.setEncoding("ascii");
_input = "";
process.stdin.on("data", function (input) {
    _input += input;
});

process.stdin.on("end", function () {
   processData(_input);
});

Python 3 version:
import queue as Queue

cntr = 0

class Node:
    def __init__(self, freq, data):
        self.freq = freq
        self.data = data
        self.left = None
        self.right = None
        global cntr
        self._count = cntr
        cntr = cntr + 1
        
    def __lt__(self, other):
        if self.freq != other.freq:
            return self.freq < other.freq
        return self._count < other._count

def huffman_hidden():#builds the tree and returns root
    q = Queue.PriorityQueue()

    
    for key in freq:
        q.put((freq[key], key, Node(freq[key], key) ))
    
    while q.qsize() != 1:
        a = q.get()
        b = q.get()
        obj = Node(a[0] + b[0], '\0' )
        obj.left = a[2]
        obj.right = b[2]
        q.put((obj.freq, obj.data, obj ))
        
    root = q.get()
    root = root[2]#contains root object
    return root

def dfs_hidden(obj, already):
    if(obj == None):
        return
    elif(obj.data != '\0'):
        code_hidden[obj.data] = already
        
    dfs_hidden(obj.right, already + "1")
    dfs_hidden(obj.left, already + "0")

"""class Node:
    def __init__(self, freq,data):
        self.freq= freq
        self.data=data
        self.left = None
        self.right = None
"""        

# Enter your code here. Read input from STDIN. Print output to STDOUT
def decodeHuff(root, s):
    result = []
    node = root
    for bit in s:
        if bit == '0':
            node = node.left
        else:
            node = node.right
        # If it's a leaf node
        if node.left is None and node.right is None:
            result.append(node.data)
            node = root
    print(''.join(result))


ip = input()
freq = {}#maps each character to its frequency

cntr = 0

for ch in ip:
    if(freq.get(ch) == None):
        freq[ch] = 1
    else:
        freq[ch]+=1

root = huffman_hidden()#contains root of huffman tree

code_hidden = {}#contains code for each object

dfs_hidden(root, "")

if len(code_hidden) == 1:#if there is only one character in the i/p
    for key in code_hidden:
        code_hidden[key] = "0"

toBeDecoded = ""

for ch in ip:
   toBeDecoded += code_hidden[ch]

decodeHuff(root, toBeDecoded)

---------------------------------------------------------------------------------------

Binary Search Tree: Lowest Common Ancestor
You are given pointer to the root of the binary search tree and two values v1 and v2. 
You need to return the lowest common ancestor (LCA) of v1 and v2 in the binary search tree.
	2
       / \
      1   3
         / \
        4   5
	    |
            6
In the diagram above, the lowest common ancestor of the nodes 4 and 6 is the node 3. 
Node 3 is the lowest node which has nodes 4 and 6 as descendants.
Function Description:
Complete the function lca in the editor below. 
It should return a pointer to the lowest common ancestor node of the two values given.
lca has the following parameters:
- root: a pointer to the root node of a binary search tree
- v1: a node.data value
- v2: a node.data value
Input Format:
The first line contains an integer, n, the number of nodes in the tree.
The second line contains n space-separated integers representing node.data values.
The third line contains two space-separated integers, v1 and v2.
To use the test data, you will have to create the binary search tree yourself. 
Here on the platform, the tree will be created for you.
Constraints:
1 <= n,node.data <= 25
1 <= v1,v2 <= 25
v1 !== v2
The tree will contain nodes with data equal to v1 and v2.

function lca(root, v1, v2) {
    while (root) {
        if (root.data > v1 && root.data > v2) {
            root = root.left;
        } else if (root.data < v1 && root.data < v2) {
            root = root.right;
        } else {
            return root;
        }
    }
}

-----------------------------------------------------------------------------
No prefix Set
There is a given list of strings where each string contains only lowercase letters from a - j, inclusive. 
The set of strings is said to be a GOOD SET if no string is a prefix of another string. 
In this case, print GOOD SET. Otherwise, print BAD SET on the first line followed by the string being checked.
Note If two strings are identical, they are prefixes of each other.
Example:
words = ['abcd','bcd','abcde','bcde']
Here 'abcd' is a prefix of 'abcde' and 'bcd' is a prefix of 'bcde'. Since 'abcde' is tested first, print
BAD SET  
abcde
words = ['ab','bc','cd'].
No string is a prefix of another so print
GOOD SET 
Function Description:
Complete the noPrefix function in the editor below.
noPrefix has the following parameter(s):
- string words[n]: an array of strings
Prints:
- string(s): either GOOD SET or BAD SET on one line followed by the word on the next line. No return value is expected.
Input Format:
First line contains n, the size of words[].
Then next n lines each contain a string, words[i].
Constraints:
1 <= n <= 10^5
1 <= the length of words[i] <= 60

'use strict';

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}

/*
 * Complete the 'noPrefix' function below.
 *
 * The function accepts STRING_ARRAY words as parameter.
 */

function noPrefix(words) {
    // Write your code here
	class TrieNode {
        constructor() {
            this.children = new Map();
            this.isEnd = false;
        }
    }

    const root = new TrieNode();

    for (const word of words) {
        let node = root;
        for (let i = 0; i < word.length; i++) {
            const ch = word[i];

            // If current node is end of another word, current word has prefix in set
            if (node.isEnd) {
                console.log("BAD SET");
                console.log(word);
                return;
            }

            if (!node.children.has(ch)) {
                node.children.set(ch, new TrieNode());
            }
            node = node.children.get(ch);
        }

        // If current word is prefix of previously inserted word(s)
        if (node.children.size > 0 || node.isEnd) {
            console.log("BAD SET");
            console.log(word);
            return;
        }

        node.isEnd = true; // Mark end of current word
    }

    console.log("GOOD SET");

}

function main() {
    const n = parseInt(readLine().trim(), 10);

    let words = [];

    for (let i = 0; i < n; i++) {
        const wordsItem = readLine();
        words.push(wordsItem);
    }

    noPrefix(words);
}
----------------------------------------------------------------------------------------------------
Castle on the Grid
You are given a square grid with some cells open (.) and some blocked (X). 
Your playing piece can move along any row or column until it reaches the edge of the grid or a blocked cell. 
Given a grid, a start and a goal, determine the minmum number of moves to get to the goal.
Example.
grid = ['...','.X.','...']
startX = 0
startY = 0
goalX = 1
goalY = 2
The grid is shown below:
...
.X.
...
The starting position (startX,startY) = (0, 0) so start in the top left corner. 
The goal is (goalX, goalY) = (1,2). The path is (0,0) --> (0,2) --> (1,2). It takes 2 moves to reach the goal.
Function Description:
Complete the minimumMoves function in the editor.
minimumMoves has the following parameter(s):
* string grid[n]: an array of strings that represent the rows of the grid
* int startX: starting X coordinate
* int startY: starting Y coordinate
* int goalX: ending X coordinate
* int goalY: ending Y coordinate
Returns:
* int: the minimum moves to reach the goal
Input Format:
The first line contains an integer n, the size of the array grid.
Each of the next n lines contains a string of length n.
The last line contains four space-separated integers, startX, startY, goalX, goalY
Constraints:
1 <= n <= 100
0 <= startX, startY, goalX, goalY < n

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}

/*
 * Complete the 'minimumMoves' function below.
 *
 * The function is expected to return an INTEGER.
 * The function accepts following parameters:
 *  1. STRING_ARRAY grid
 *  2. INTEGER startX
 *  3. INTEGER startY
 *  4. INTEGER goalX
 *  5. INTEGER goalY
 */

function minimumMoves(grid, startX, startY, goalX, goalY) {
    // Write your code here

}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const n = parseInt(readLine().trim(), 10);

    let grid = [];

    for (let i = 0; i < n; i++) {
        const gridItem = readLine();
        grid.push(gridItem);
    }

    const firstMultipleInput = readLine().replace(/\s+$/g, '').split(' ');

    const startX = parseInt(firstMultipleInput[0], 10);

    const startY = parseInt(firstMultipleInput[1], 10);

    const goalX = parseInt(firstMultipleInput[2], 10);

    const goalY = parseInt(firstMultipleInput[3], 10);

    const result = minimumMoves(grid, startX, startY, goalX, goalY);

    ws.write(result + '\n');

    ws.end();
}
-------------------------------------------------------------------------------------

Determine the minimum cost to provide library access to all citizens of HackerLand. 
There are n cities numbered from 1 to n. Currently there are no libraries and the cities are not connected. 
Bidirectional roads may be built between any city pair listed in cities. A citizen has access to a library if:
* Their city contains a library.
* They can travel by road from their city to a city containing a library.
Example:
The following figure is a sample map of HackerLand where the dotted lines denote possible roads:
c_road = 2
c_lib = 3
cities = [[1,7],[1,3],[1,2],[2,3],[5,6],[6,8]]
The cost of building any road is cc+road = 2, and the cost to build a library in any city is c_lib = 3. 
Build 5 roads at a cost of 5 X 2 = 10 and 2 libraries for a cost of 6. 
One of the available roads in the cycle 1 --> 2 --> 3 --> 1 is not necessary.
There are q queries, where each query consists of a map of HackerLand and value of c_lib and c_road. 
For each query, find the minimum cost to make libraries accessible to all the citizens.
Function Description:
Complete the function roadsAndLibraries in the editor below.
roadsAndLibraries has the following parameters:
* int n: integer, the number of cities
* int c_lib: integer, the cost to build a library
* int c_road: integer, the cost to repair a road
* int cities[m][2]: each cities[i] contains two integers that represent cities that can be connected by a new road
Returns:
- int: the minimal cost
Input Format:
The first line contains a single integer q, that denotes the number of queries.
The subsequent lines describe each query in the following format:
- The first line contains four space-separated integers that describe the respective values of n, m, c_lib and c_road, 
the number of cities, number of roads, cost of a library and cost of a road.
- Each of the next m lines contains two space-separated integers, u[i] and v[i], 
that describe a bidirectional road that can be built to connect cities u[i] and v[i].
Constraints:
1 <= q <= 10
1 <= n <= 10^5
0 <= m <= min(10^5, (n*(n-1))/2)
1 <= c_road, c_lib <= 10^5
1 <= u[i], v[i] <= n
Each road connects two distinvt cities.



'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}

/*
 * Complete the 'roadsAndLibraries' function below.
 *
 * The function is expected to return a LONG_INTEGER.
 * The function accepts following parameters:
 *  1. INTEGER n
 *  2. INTEGER c_lib
 *  3. INTEGER c_road
 *  4. 2D_INTEGER_ARRAY cities
 */

function roadsAndLibraries(n, c_lib, c_road, cities) {
    // Write your code here
	if (c_lib <= c_road) {
        return n * c_lib;
    }

    // Build adjacency list
    const graph = Array.from({ length: n + 1 }, () => []);
    for (const [u, v] of cities) {
        graph[u].push(v);
        graph[v].push(u);
    }

    const visited = new Array(n + 1).fill(false);
    let totalCost = 0;

    function bfs(start) {
        const queue = [start];
        visited[start] = true;
        let size = 1;
        while (queue.length) {
            const node = queue.shift();
            for (const neighbor of graph[node]) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    queue.push(neighbor);
                    size++;
                }
            }
        }
        return size;
    }

    for (let city = 1; city <= n; city++) {
        if (!visited[city]) {
            const componentSize = bfs(city);
            totalCost += c_lib + (componentSize - 1) * c_road;
        }
    }
    return totalCost;

}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const q = parseInt(readLine().trim(), 10);

    for (let qItr = 0; qItr < q; qItr++) {
        const firstMultipleInput = readLine().replace(/\s+$/g, '').split(' ');

        const n = parseInt(firstMultipleInput[0], 10);

        const m = parseInt(firstMultipleInput[1], 10);

        const c_lib = parseInt(firstMultipleInput[2], 10);

        const c_road = parseInt(firstMultipleInput[3], 10);

        let cities = Array(m);

        for (let i = 0; i < m; i++) {
            cities[i] = readLine().replace(/\s+$/g, '').split(' ').map(citiesTemp => parseInt(citiesTemp, 10));
        }

        const result = roadsAndLibraries(n, c_lib, c_road, cities);

        ws.write(result + '\n');
    }

    ws.end();
}
--------------------------------------------------------------------------------------------------------------
Breadth First Search: Shortest Reach
Consider an undirected graph where each edge weighs 6 units. Each of the nodes is labeled consecutively from 1 to n.
You will be given a number of queries. For each query, you will be given a list of edges describing an undirected graph. 
After you create a represantation of the graph, you must determine and report the shortest distance to each of the other nodes
from a given starting position using the breadth-first search algorithm (BFS). Return an array of distances from the start node in node number order.
If a node is unreachable, return -1 for that node.
Example:
The following graph is based on the listed inputs:
	1/Start		5
	/ \ 
       2   3
	   |
	   4
n = 5; number of nodes
m = 3; number of edges
edges = [1,2],[1,3],[3,4]
s = 1; starting node
All distances are from the start node 1. Output are calculated for distances to nodes 2 through 5: [6,6,12,-1]. Each edge is 6 units,
and the unreachable node 5 has the required return distance of -1.
Function Description:
Complete the bfs function in the editor below. If a node is unreachable, its distance is -1.
bfs has the following parameters:
* int n: the number of nodes
* int m: the number of edges
* int edges[m][2]: start and end nodes for edges
* int s: the node to start traversals from
Returns:
* int[n-1]: the distances to nodes in increasing node number order, not including the start node(-1 if a node is unreachable)
Input Format:
The first line contains an integer q, the number of queries. Each of the following q sets of lines has the following format:
* The first line contains two space-separated integers n and m, the number of nodes and edges in the graph.
* Each line i of the m subsequent lines contains two space-separated integers, u and v, that describe an edge between nodes u and v.
* The last line contains a single integer, s, the node number to start from.
Constraints:
1 <= q <= 10
2 <= n <= 1000
1 <= m <= (n*(n-1))/2
1 <= u, v, s <= n

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}



/*
 * Complete the 'bfs' function below.
 *
 * The function is expected to return an INTEGER_ARRAY.
 * The function accepts following parameters:
 *  1. INTEGER n
 *  2. INTEGER m
 *  3. 2D_INTEGER_ARRAY edges
 *  4. INTEGER s
 */

function bfs(n, m, edges, s) {
    // Write your code here
	// Build adjacency list (1-based indexing)
    const graph = Array.from({ length: n + 1 }, () => []);
    for (const [u, v] of edges) {
        graph[u].push(v);
        graph[v].push(u);
    }

    // Initialize distances with -1 (unreachable)
    const distances = new Array(n + 1).fill(-1);
    distances[s] = 0;

    // BFS Queue
    const queue = [];
    queue.push(s);

    while (queue.length) {
        const node = queue.shift();

        for (const neighbor of graph[node]) {
            if (distances[neighbor] === -1) {  // Not visited
                distances[neighbor] = distances[node] + 6; // Edge weight = 6
                queue.push(neighbor);
            }
        }
    }

    // Prepare result array excluding the start node
    const result = [];
    for (let node = 1; node <= n; node++) {
        if (node !== s) {
            result.push(distances[node]);
        }
    }

    return result;

}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const q = parseInt(readLine().trim(), 10);

    for (let qItr = 0; qItr < q; qItr++) {
        const firstMultipleInput = readLine().replace(/\s+$/g, '').split(' ');

        const n = parseInt(firstMultipleInput[0], 10);

        const m = parseInt(firstMultipleInput[1], 10);

        let edges = Array(m);

        for (let i = 0; i < m; i++) {
            edges[i] = readLine().replace(/\s+$/g, '').split(' ').map(edgesTemp => parseInt(edgesTemp, 10));
        }

        const s = parseInt(readLine().trim(), 10);

        const result = bfs(n, m, edges, s);

        ws.write(result.join(' ') + '\n');
    }

    ws.end();
}
------------------------------------------------------------------------------------------------
Components in a graph
There are 2 X N nodes in an undirected graph, and a number of edges connecting some nodes. In each edge, the first value
will be between 1 and N, inclusive. The second node will be between N + 1 and 2 X N, inclusive. Given a list of edges,
determine the size of the smallest and largest connected components that have 2 or more nodes. A node can have any
number of connections. The highest node value will always be connected to at least 1 other node.
Note: Single nodes should not be considered in the answer.
Example:
bg = [[1,5],[1,6],[2,4]]
	3

	2 -- 4

	  5
         / 
	1 -- 6
The smaller componet contains 2 nodes and the larger contains 3. Return the array [2,3].
Function Description:
Complete the connectedComponents function in the editor below. connectedComponents has the following parameters:
* int bg[n][2]: a 2-d array of integers that represent node ends of graph edges.
Returns:
* int[2]: an array with 2 integers, the smallest and largest component sizes.
Input Format:
The first line contains an integer n, the size of bg.
Each of the next n lines contain two space-separated integers, bg[i][0] and bg[i][1].
Constraints:
1 <= numberofnodesN <= 15000
1 <= bg[i][0] <= N
N+1 <= bg[i][1] <= 2N

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}



/*
 * Complete the 'componentsInGraph' function below.
 *
 * The function is expected to return an INTEGER_ARRAY.
 * The function accepts 2D_INTEGER_ARRAY gb as parameter.
 */

class DisjointSet {
    constructor(n) {
        this.parent = new Array(n + 1);
        this.size = new Array(n + 1);
        for (let i = 1; i <= n; i++) {
            this.parent[i] = i;
            this.size[i] = 1;
        }
    }

    find(x) {
        if (this.parent[x] !== x) {
            this.parent[x] = this.find(this.parent[x]); // Path compression
        }
        return this.parent[x];
    }

    union(a, b) {
        let rootA = this.find(a);
        let rootB = this.find(b);
        if (rootA !== rootB) {
            // Union by size
            if (this.size[rootA] < this.size[rootB]) {
                [rootA, rootB] = [rootB, rootA];
            }
            this.parent[rootB] = rootA;
            this.size[rootA] += this.size[rootB];
            this.size[rootB] = 0;
        }
    }
}

function componentsInGraph(gb) {
    // Determine max node to size arrays
    let maxNode = 0;
    for (const [u, v] of gb) {
        maxNode = Math.max(maxNode, u, v);
    }

    const dsu = new DisjointSet(maxNode);

    for (const [u, v] of gb) {
        dsu.union(u, v);
    }

    let minSize = Number.MAX_SAFE_INTEGER;
    let maxSize = 0;

    for (let i = 1; i <= maxNode; i++) {
        // Only root nodes
        if (dsu.parent[i] === i && dsu.size[i] > 1) {
            if (dsu.size[i] < minSize) {
                minSize = dsu.size[i];
            }
            if (dsu.size[i] > maxSize) {
                maxSize = dsu.size[i];
            }
        }
    }

    return [minSize, maxSize];
}


}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const n = parseInt(readLine().trim(), 10);

    let gb = Array(n);

    for (let i = 0; i < n; i++) {
        gb[i] = readLine().replace(/\s+$/g, '').split(' ').map(gbTemp => parseInt(gbTemp, 10));
    }

    const result = componentsInGraph(gb);

    ws.write(result.join(' ') + '\n');

    ws.end();
}
---------------------------------------------------------------------------------------------------

Cut the tree
There is an undirected tree where each vertex is numbered from 1 to n, and each contains a data value.
The sum of a tree is the sum of all its nodes' data values. If an edge is cut, two smaller trees are formed.
The difference between two trees is the absolute value of the difference in their sums.
Given a tree, determine which edge to cut so that the resulting trees have a minimal difference.
Example:
data = [1,2,3,4,5,6]
edges = [(1,2),(1,3),(2,6),(3,4),(3,5)]
In this case, node numbers match their weights for convenience. The is shown below:
			3
		2---------------6
	       /
            1 /
	     /
	    /
           1
            \
             \ 2
              \
               \        4
		3---------------4
                 \
                  \
                   \ 5
                    \
                     \
                      5
The values are calculated as follows:
edge cut	Tree1 sum	Tree2 sum	Absolute difference
   1		   8               13                 5
   2               9               12                 3
   3               6               15                 9
   4               4               17                 13
   5               5               16                 11
The minimum absolute difference is 3.
Note: The given tree is always rooted at vertex 1.
Function Description:
Complete the cutTheTree function.
cutTheTree function has the following parameters:
* int data[n]: an array of integers that represent node values.
* int edgee[n-1][2]: an 2-d array of integer pairs where each pair represents nodes connected by the edge.
Returns:
* int:the minimum achievable absolute difference of tree sums.
Input Format:
The first line contains an integer n, the number of vertices in the tree.
The second line contains n space-separated integers, where each integer u denotes the node[u] data value, data[u].
Each of the n-1 subsequent lines contains two space-separated integers u and v that describe edge u<->v in a tree t.
Constraints:
3 <= n <= 10^5
1 <= data[u] <= 1001, where 1 <= u <= n.

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}



/*
 * Complete the 'cutTheTree' function below.
 *
 * The function is expected to return an INTEGER.
 * The function accepts following parameters:
 *  1. INTEGER_ARRAY data
 *  2. 2D_INTEGER_ARRAY edges
 */

function cutTheTree(data, edges) {
    const n = data.length;
    const adj = Array.from({ length: n + 1 }, () => []);

    for (const [u, v] of edges) {
        adj[u].push(v);
        adj[v].push(u);
    }

    const totalSum = data.reduce((acc, val) => acc + val, 0);
    let minDiff = Number.MAX_SAFE_INTEGER;

    const visited = new Array(n + 1).fill(false);

    function dfs(node) {
        visited[node] = true;
        let currSum = data[node - 1];
        for (const neighbor of adj[node]) {
            if (!visited[neighbor]) {
                currSum += dfs(neighbor);
            }
        }
        if (node !== 1) {
            // Cutting edge between node and its parent splits the tree
            const diff = Math.abs(totalSum - 2 * currSum);
            if (diff < minDiff) minDiff = diff;
        }
        return currSum;
    }

    dfs(1);

    return minDiff;
}


function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const n = parseInt(readLine().trim(), 10);

    const data = readLine().replace(/\s+$/g, '').split(' ').map(dataTemp => parseInt(dataTemp, 10));

    let edges = Array(n - 1);

    for (let i = 0; i < n - 1; i++) {
        edges[i] = readLine().replace(/\s+$/g, '').split(' ').map(edgesTemp => parseInt(edgesTemp, 10));
    }

    const result = cutTheTree(data, edges);

    ws.write(result + '\n');

    ws.end();
}
-----------------------------------------------------------------------------------------

































