Lego Blocks
You have an infinite number of 4 types of lego blocks of sizes given as (depth x height x width):

d	h	w
1	1	1
1	1	2
1	1	3
1	1	4
Using these blocks, you want to make a wall of height n and width m. Features of the wall are:
- The wall should not have any holes in it.
- The wall you build should be one solid structure, so there should not be a straight vertical break across all rows of bricks.
- The bricks must be laid horizontally.
How many ways can the wall be built?
Example:
n = 2
m = 3
The height is 2 and the width is 3.
There are 9 valid permutations in all.
Function Description:
Complete the legoBlocks function in the editor below.
legoBlocks has the following parameter(s):
* int n: the height of the wall
* int m: the width of the wall
Returns:
- int: the number of valid wall formations modulo 
Input Format:
The first line contains the number of test cases t.
Each of the next t lines contains two space-separated integers n and m.
Constraints:
1 <= t <= 100
1 <= n,m <= 1000

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}

/*
 * Complete the 'legoBlocks' function below.
 *
 * The function is expected to return an INTEGER.
 * The function accepts following parameters:
 *  1. INTEGER n
 *  2. INTEGER m
 */
const MOD = 1000000007;
const maxM = 1000;
// Precompute T_arr for widths 0 to maxM
const T_arr = new Array(maxM + 1).fill(0n);
T_arr[0] = 1n;
for(let i = 1; i < maxM; i++) {
	T_arr[i] = 0n;
	if(i >= 1) T_arr[i] = (T_arr[i] + T_arr[i - 1]) % MOD;
	if(i >= 2) T_arr[i] = (T_arr[i] + T_arr[i - 2]) % MOD;
	if(i >= 3) T_arr[i] = (T_arr[i] + T_arr[i - 3]) % MOD;
	if(i >= 4) T_arr[i] = (T_arr[i] + T_arr[i - 4]) % MOD;
}

function modPowBigInt(base, exponent, modulus) {
	let result = 1n;
	base = base % modulus;
	
	while(exponent > 0n) {
		if(exponent % 2n === 1n) {
			result = (result * base) % modulus;
		}
		exponent = exponent >> 1n;
		base = (base * base) % modulus;
		
	}
	return result;
}

function legoBlocks(n, m) {
    // Write your code here
	const n_big = BigInt(n);
	const U = new Array(m + 1).fill(0n);
	for(let i = 1; i <= m; i++) {
		U[i] = modPowBigInt(T_arr[i], n_big, MOD);
	}
	const G = new Array(m + 1).fill(0n);
	G[0] = 1n;
	for(let i = 1; i <= m; i++) {
		let sum = 0n;
		for(let j = 1; j < i; j++) {
			const product = (G[j] * U[i - j]) % MOD;
			sum = (sum + product) % MOD;
			
		}
		G[i] = (U[i] - sum + MOD) % MOD;
	}
	return Number(G[m] % MOD);
	
}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const t = parseInt(readLine().trim(), 10);

    for (let tItr = 0; tItr < t; tItr++) {
        const firstMultipleInput = readLine().replace(/\s+$/g, '').split(' ');

        const n = parseInt(firstMultipleInput[0], 10);

        const m = parseInt(firstMultipleInput[1], 10);

        const result = legoBlocks(n, m);

        ws.write(result + '\n');
    }

    ws.end();
}
--------------------------------------------------------------------------
QHEAP1
This question is designed to help you get a better understanding of basic heap operations.
There are 3 types of query:
* "1 v " - Add an element v to the heap.
* "2 v " - Delete the element v from the heap.
* "3" - Print the minimum of all the elements in the heap.
NOTE: It is guaranteed that the element to be deleted will be there in the heap. 
Also, at any instant, only distinct elements will be in the heap.
Input Format:
The first line contains the number of queries, Q.
Each of the next Q lines contains one of the 3 types of query.
Constraints:
1 <= Q <= 10^5
-10^9 <= v <= 10^9

function processData(input) {
    const lines = input.trim().split('\n');
    const Q = parseInt(lines[0]);
    const heap = [];
    const valueToIndex = new Map(); // value -> index in heap

    function swap(i, j) {
        [heap[i], heap[j]] = [heap[j], heap[i]];
        valueToIndex.set(heap[i], i);
        valueToIndex.set(heap[j], j);
    }

    function heapifyUp(index) {
        while (index > 0) {
            let parent = Math.floor((index - 1) / 2);
            if (heap[parent] > heap[index]) {
                swap(parent, index);
                index = parent;
            } else break;
        }
    }

    function heapifyDown(index) {
        let left, right, smallest;
        while (true) {
            left = 2 * index + 1;
            right = 2 * index + 2;
            smallest = index;
            if (left < heap.length && heap[left] < heap[smallest]) smallest = left;
            if (right < heap.length && heap[right] < heap[smallest]) smallest = right;
            if (smallest !== index) {
                swap(index, smallest);
                index = smallest;
            } else break;
        }
    }

    for (let i = 1; i <= Q; i++) {
        const parts = lines[i].trim().split(' ');
        const type = parts[0];
        if (type === '1') {
            // Insert
            const v = parseInt(parts[1]);
            heap.push(v);
            valueToIndex.set(v, heap.length - 1);
            heapifyUp(heap.length - 1);
        } else if (type === '2') {
            // Delete
            const v = parseInt(parts[1]);
            const idx = valueToIndex.get(v);
            const last = heap.length - 1;
            if (idx !== last) {
                swap(idx, last);
            }
            heap.pop();
            valueToIndex.delete(v);
            if (idx < heap.length) {
                heapifyUp(idx);
                heapifyDown(idx);
            }
        } else if (type === '3') {
            // Print min
            console.log(heap[0]);
        }
    }
}


process.stdin.resume();
process.stdin.setEncoding("ascii");
_input = "";
process.stdin.on("data", function (input) {
    _input += input;
});

process.stdin.on("end", function () {
   processData(_input);
});
--------------------------------------------------------------------

Jesse and Cookies
Jesse loves cookies and wants the sweetness of some cookies to be greater than value k. 
To do this, two cookies with the least sweetness are repeatedly mixed. 
This creates a special combined cookie with:
sweetness = (1 X Least sweet cookie + 2 X 2nd least sweet cookie).
This occurs until all the cookies have a sweetness >= k.
Given the sweetness of a number of cookies, determine the minimum number of operations required. 
If it is not possible, return -1.
Example:
k = 9
A = [2,7,3,6,4,6]
The smallest values are 2, 3.
Remove them then return 2 + 2 X 3 = 8 to the array. Now A = [8,7,6,4,6].
Remove 4,6 and return 4 + 6 X 2 = 16 to the array. Now A = [16,8,7,6].
Remove 6,7, return 6 + 2 X 7 = 20 and A = [20,16,8,7].
Finally, remove 8,7 and return 7 + 2 X 8 = 23 to A. Now A = [23,20,16].
All values are >= k=9 so the process stops after 4 iterations. Return 4.
Function Description:
Complete the cookies function in the editor below.
cookies has the following parameters:
* int k: the threshold value
* int A[n]: an array of sweetness values
Returns:
* int: the number of iterations required or 
Input Format:
The first line has two space-separated integers, n and k, the size of A[] and 
the minimum required sweetness respectively.
The next line contains n space-separated integers, A[i].
Constraints:
1 <= n < 10^6
0 <= k <= 10^9
0 <= A[i] <= 10^6

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}

/*
 * Complete the 'cookies' function below.
 *
 * The function is expected to return an INTEGER.
 * The function accepts following parameters:
 *  1. INTEGER k
 *  2. INTEGER_ARRAY A
 */

class MinHeap {
    constructor(data = []) {
        this.heap = data;
        if (this.heap.length > 0) {
            this.buildHeap();
        }
    }

    buildHeap() {
        for (let i = Math.floor(this.heap.length / 2) - 1; i >= 0; i--) {
            this.heapifyDown(i);
        }
    }

    size() {
        return this.heap.length;
    }

    peek() {
        return this.heap.length > 0 ? this.heap[0] : undefined;
    }

    insert(value) {
        this.heap.push(value);
        this.heapifyUp(this.heap.length - 1);
    }

    extractMin() {
        if (this.heap.length === 0) return undefined;
        const min = this.heap[0];
        const last = this.heap.pop();
        if (this.heap.length > 0) {
            this.heap[0] = last;
            this.heapifyDown(0);
        }
        return min;
    }

    heapifyUp(index) {
        let current = index;
        while (current > 0) {
            const parent = Math.floor((current - 1) / 2);
            if (this.heap[parent] > this.heap[current]) {
                [this.heap[parent], this.heap[current]] = [this.heap[current], this.heap[parent]];
                current = parent;
            } else {
                break;
            }
        }
    }

    heapifyDown(index) {
        let current = index;
        const n = this.heap.length;
        while (true) {
            const left = 2 * current + 1;
            const right = 2 * current + 2;
            let smallest = current;

            if (left < n && this.heap[left] < this.heap[smallest]) {
                smallest = left;
            }
            if (right < n && this.heap[right] < this.heap[smallest]) {
                smallest = right;
            }

            if (smallest !== current) {
                [this.heap[current], this.heap[smallest]] = [this.heap[smallest], this.heap[current]];
                current = smallest;
            } else {
                break;
            }
        }
    }
}

function cookies(k, A) {
    const heap = new MinHeap(A);
    let ops = 0;

    while (heap.size() >= 2 && heap.peek() < k) {
        const a = heap.extractMin();
        const b = heap.extractMin();
        const newCookie = a + 2 * b;
        heap.insert(newCookie);
        ops++;
    }

    if (heap.peek() < k) {
        return -1;
    } else {
        return ops;
    }
}

function processData(input) {
    const lines = input.trim().split('\n');
    const firstLine = lines[0].split(' ');
    const n = parseInt(firstLine[0]);
    const k = parseInt(firstLine[1]);
    const A = lines[1].split(' ').map(Number);
    console.log(cookies(k, A));
}


function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const firstMultipleInput = readLine().replace(/\s+$/g, '').split(' ');

    const n = parseInt(firstMultipleInput[0], 10);

    const k = parseInt(firstMultipleInput[1], 10);

    const A = readLine().replace(/\s+$/g, '').split(' ').map(ATemp => parseInt(ATemp, 10));

    const result = cookies(k, A);

    ws.write(result + '\n');

    ws.end();
}
------------------------------------------------------------------------------
Hackerland Radio Transmitters
Hackerland is a one-dimensional city with houses aligned at integral locations along a road. 
The Mayor wants to install radio transmitters on the roofs of the city's houses. 
Each transmitter has a fixed range meaning it can transmit a signal to all houses within that number of units distance away.
Given a map of Hackerland and the transmission range, determine the minimum number of transmitters so that every 
house is within range of at least one transmitter. Each transmitter must be installed on top of an existing house.
Example:
x = [1,2,3,5,9]
k = 1
3 antennae at houses 2 and 5 and 9 provide complete coverage. There is no house at location 7 to cover both 5 and 9. 
Ranges of coverage, are [1,2,3], [5], and [9].
Function Description:
Complete the hackerlandRadioTransmitters function in the editor below.
hackerlandRadioTransmitters has the following parameter(s):
* int x[n]: the locations of houses
* int k: the effective range of a transmitter
Returns:
* int: the minimum number of transmitters to install
Input Format:
The first line contains two space-separated integers n and k, the number of houses in Hackerland and the range of each transmitter.
The second line contains n space-separated integers describing the respective locations of each house x[i].
Constraints:
1 <= n,k <= 10^5
1 <= x[i] <= 10^5
There may be more than one house at the same location.

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}

/*
 * Complete the 'hackerlandRadioTransmitters' function below.
 *
 * The function is expected to return an INTEGER.
 * The function accepts following parameters:
 *  1. INTEGER_ARRAY x
 *  2. INTEGER k
 */

function hackerlandRadioTransmitters(x, k) {
    // Write your code here
	if (x.length === 0) return 0;
    
    	const houses = [...new Set(x)].sort((a, b) => a - b);
    	const n = houses.length;
    	let count = 0;
    	let i = 0;
    
    	while (i < n) {
        	count++;
        	let j = i;
        	while (j < n && houses[j] <= houses[i] + k) {
            		j++;
        	}
        	const transmitterLoc = houses[j - 1];
        
        	while (i < n && houses[i] <= transmitterLoc + k) {
            		i++;
        	}
    	}
    
    	return count;
}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const firstMultipleInput = readLine().replace(/\s+$/g, '').split(' ');

    const n = parseInt(firstMultipleInput[0], 10);

    const k = parseInt(firstMultipleInput[1], 10);

    const x = readLine().replace(/\s+$/g, '').split(' ').map(xTemp => parseInt(xTemp, 10));

    const result = hackerlandRadioTransmitters(x, k);

    ws.write(result + '\n');

    ws.end();
}
-------------------------------------------------------------------------------








































