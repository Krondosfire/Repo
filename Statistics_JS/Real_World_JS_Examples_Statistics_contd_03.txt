Climbing the Leaderboard
An arcade game player wants to climb to the top of the leaderboard and track their ranking. 
The game uses Dense Ranking, so its leaderboard works like this:
* The player with the highest score is ranked number 1 on the leaderboard.
* Players who have equal scores receive the same ranking number, and the next player(s) receive the immediately following ranking number.
Example:
ranked = [100,90,90,80]
player = [70,80,105]
The ranked players will have ranks 1, 2, 2, and 3, respectively. If the player's scores are 70, 80 and 105, 
their rankings after each game are 4th, 3rd and 1st. Return [4,3,1].
Function Description:
Complete the climbingLeaderboard function in the editor below.
climbingLeaderboard has the following parameter(s):
* int ranked[n]: the leaderboard scores
* int player[m]: the player's scores
Returns:
* int[m]: the player's rank after each new score
Input Format:
The first line contains an integer n, the number of players on the leaderboard.
The next line contains n space-separated integers ranked[i], the leaderboard scores in decreasing order.
The next line contains an integer, m, the number games the player plays.
The last line contains m space-separated integers player[j], the game scores.
Constraints:
1 <= n <= 2x10^5
1 <= m <= 2x10^5
0 <= ranked[i] <= 10^9 for 0 <= i < n
0 <= player[j] <= 10^9 for 0 <= j < m
The existing leaderboard, ranked, is in descending order.
The player's scores, player, are in ascending order.
Subtask:
For 60% of the maximum score:
1 <= n <= 200
1 <= m <= 200

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}

/*
 * Complete the 'climbingLeaderboard' function below.
 *
 * The function is expected to return an INTEGER_ARRAY.
 * The function accepts following parameters:
 *  1. INTEGER_ARRAY ranked
 *  2. INTEGER_ARRAY player
 */

function climbingLeaderboard(ranked, player) {
    // Write your code here
	// Remove duplicates from ranked to get unique scores in descending order
    const uniqueRanked = [];
    for (let i = 0; i < ranked.length; i++) {
        if (i === 0 || ranked[i] !== ranked[i - 1]) {
            uniqueRanked.push(ranked[i]);
        }
    }

    const result = [];
    let i = uniqueRanked.length - 1;
    for (const score of player) {
        // Move up the leaderboard as long as player score >= ranked score
        while (i >= 0 && score >= uniqueRanked[i]) {
            i--;
        }
        // Rank is index + 2 (since index is 0-based and we want next rank after last checked)
        result.push(i + 2);
    }
    return result;
}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const rankedCount = parseInt(readLine().trim(), 10);

    const ranked = readLine().replace(/\s+$/g, '').split(' ').map(rankedTemp => parseInt(rankedTemp, 10));

    const playerCount = parseInt(readLine().trim(), 10);

    const player = readLine().replace(/\s+$/g, '').split(' ').map(playerTemp => parseInt(playerTemp, 10));

    const result = climbingLeaderboard(ranked, player);

    ws.write(result.join('\n') + '\n');

    ws.end();
}
------------------------------------------------------------------------------

Reverse a linked list
Given the pointer to the head node of a linked list, change the next pointers of the nodes so that their order is reversed. 
The head pointer given may be null meaning that the initial list is empty.
Example:
head references the list 1 --> 2 --> 3 --> NULL
Manipulate the next pointers of each node in place and return head, now referencing the head of the list 3 --> 2 --> 1 --> NULL.
Function Description:
Complete the reverse function in the editor below.
reverse has the following parameter:
* SinglyLinkedListNode pointer head: a reference to the head of a list
Returns:
* SinglyLinkedListNode pointer: a reference to the head of the reversed list
Input Format:
The first line contains an integer t, the number of test cases.
Each test case has the following format:
The first line contains an integer n, the number of elements in the linked list.
Each of the next n lines contains an integer, the data values of the elements in the linked list.
Constraints:
1 <= t <= 10
1 <= n <= 1000
1 <= list[i] <= 1000, where list[i] is the i-th element in the list.


'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', inputStdin => {
    inputString += inputStdin;
});

process.stdin.on('end', _ => {
    inputString = inputString.replace(/\s*$/, '')
        .split('\n')
        .map(str => str.replace(/\s*$/, ''));

    main();
});

function readLine() {
    return inputString[currentLine++];
}

const SinglyLinkedListNode = class {
    constructor(nodeData) {
        this.data = nodeData;
        this.next = null;
    }
};

const SinglyLinkedList = class {
    constructor() {
        this.head = null;
        this.tail = null;
    }

    insertNode(nodeData) {
        const node = new SinglyLinkedListNode(nodeData);

        if (this.head == null) {
            this.head = node;
        } else {
            this.tail.next = node;
        }

        this.tail = node;
    }
};

function printSinglyLinkedList(node, sep, ws) {
    while (node != null) {
        ws.write(String(node.data));

        node = node.next;

        if (node != null) {
            ws.write(sep);
        }
    }
}

/*
 * Complete the 'reverse' function below.
 *
 * The function is expected to return an INTEGER_SINGLY_LINKED_LIST.
 * The function accepts INTEGER_SINGLY_LINKED_LIST llist as parameter.
 */

/*
 * For your reference:
 *
 * SinglyLinkedListNode {
 *     int data;
 *     SinglyLinkedListNode next;
 * }
 *
 */

function reverse(llist) {
    // Write your code here
	let prev = null;
	let current = llist;
	while(current !== null) {
		let nextNode = current.next;
		current.next = prev;
		prev = current;
		current = nextNode;
	}
	return prev;
}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const tests = parseInt(readLine(), 10);

    for (let testsItr = 0; testsItr < tests; testsItr++) {
        const llistCount = parseInt(readLine(), 10);

        let llist = new SinglyLinkedList();

        for (let i = 0; i < llistCount; i++) {
            const llistItem = parseInt(readLine(), 10);
            llist.insertNode(llistItem);
        }

        let llist1 = reverse(llist.head);

        printSinglyLinkedList(llist1, " ", ws)
        ws.write("\n");
    }

    ws.end();
}
-----------------------------------------------------------------

Reverse a doubly linked list
Given the pointer to the head node of a doubly linked list, reverse the order of the nodes in place. 
That is, change the next and prev pointers of the nodes so that the direction of the list is reversed. 
Return a reference to the head node of the reversed list.
Note: The head node might be NULL to indicate that the list is empty.
Function Description:
Complete the reverse function in the editor below.
reverse has the following parameter(s):
* DoublyLinkedListNode head: a reference to the head of a DoublyLinkedList
Returns:
* DoublyLinkedListNode: a reference to the head of the reversed list
Input Format:
The first line contains an integer t, the number of test cases.
Each test case is of the following format:
The first line contains an integer n, the number of elements in the linked list.
The next n lines contain an integer each denoting an element of the linked list.
Constraints:
1 <= t <= 10
0 <= n <= 1000
0 <= DoublyLinkedListNode.data <= 1000

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', inputStdin => {
    inputString += inputStdin;
});

process.stdin.on('end', _ => {
    inputString = inputString.replace(/\s*$/, '')
        .split('\n')
        .map(str => str.replace(/\s*$/, ''));

    main();
});

function readLine() {
    return inputString[currentLine++];
}

const DoublyLinkedListNode = class {
    constructor(nodeData) {
        this.data = nodeData;
        this.next = null;
        this.prev = null;
    }
};

const DoublyLinkedList = class {
    constructor() {
        this.head = null;
        this.tail = null;
    }

    insertNode(nodeData) {
        let node = new DoublyLinkedListNode(nodeData);

        if (this.head == null) {
            this.head = node;
        } else {
            this.tail.next = node;
            node.prev = this.tail;
        }

        this.tail = node;
    }
};

function printDoublyLinkedList(node, sep, ws) {
    while (node != null) {
        ws.write(String(node.data));

        node = node.next;

        if (node != null) {
            ws.write(sep);
        }
    }
}

/*
 * Complete the 'reverse' function below.
 *
 * The function is expected to return an INTEGER_DOUBLY_LINKED_LIST.
 * The function accepts INTEGER_DOUBLY_LINKED_LIST llist as parameter.
 */

/*
 * For your reference:
 *
 * DoublyLinkedListNode {
 *     int data;
 *     DoublyLinkedListNode next;
 *     DoublyLinkedListNode prev;
 * }
 *
 */

function reverse(llist) {
    // Write your code here
	let current = llist;
	let temp = null;
	let newHead = null;
	while(current !== null) {
		// Swap next and prev for current node
		temp = current.prev;
		current.prev = current.next;
		current.next = temp;
		// Move to the next node in the original list(which is prev now)
		newHead = current;
		current = current.prev;
	}
	return newHead;
}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const t = parseInt(readLine(), 10);

    for (let tItr = 0; tItr < t; tItr++) {
        const llistCount = parseInt(readLine(), 10);

        let llist = new DoublyLinkedList();

        for (let i = 0; i < llistCount; i++) {
            const llistItem = parseInt(readLine(), 10);
            llist.insertNode(llistItem);
        }

        let llist1 = reverse(llist.head);

        printDoublyLinkedList(llist1, " ", ws)
        ws.write("\n");
    }

    ws.end();
}
--------------------------------------------------------------------------

Insert a node at a specific position in a linked list
Given the pointer to the head node of a linked list and an integer to insert at a certain position, create a new node 
with the given integer as its data attribute, insert this node at the desired position and return the head node.
A position of 0 indicates head, a position of 1 indicates one node away from the head and so on. 
The head pointer given may be null meaning that the initial list is empty.
Example:
head refers to the first node in the list 1 --> 2 --> 3
data = 4
position = 2
Insert a node at position 2 with data = 4. The new list is 1 --> 2 --> 4 --> 3
Function Description: 
Complete the function insertNodeAtPosition in the editor below. It must return a reference to the head node of your finished list.
insertNodeAtPosition has the following parameters:
* head: a SinglyLinkedListNode pointer to the head of the list
* data: an integer value to insert as data in your new node
* position: an integer position to insert the new node, zero based indexing
Returns:
* SinglyLinkedListNode pointer: a reference to the head of the revised list
Input Format:
The first line contains an integer n, the number of elements in the linked list.
Each of the next n lines contains an integer SinglyLinkedListNode[i].data.
The next line contains an integer data, the data of the node that is to be inserted.
The last line contains an integer position.
Constraints:
1 <= n <= 1000
1 <= SinglyLinkedListNode[i].data <= 1000, where SinglyLinkedListNode[i] is the i-th element of the linked list
0 <= position <= n

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', inputStdin => {
    inputString += inputStdin;
});

process.stdin.on('end', _ => {
    inputString = inputString.replace(/\s*$/, '')
        .split('\n')
        .map(str => str.replace(/\s*$/, ''));

    main();
});

function readLine() {
    return inputString[currentLine++];
}

const SinglyLinkedListNode = class {
    constructor(nodeData) {
        this.data = nodeData;
        this.next = null;
    }
};

const SinglyLinkedList = class {
    constructor() {
        this.head = null;
        this.tail = null;
    }

    insertNode(nodeData) {
        const node = new SinglyLinkedListNode(nodeData);

        if (this.head == null) {
            this.head = node;
        } else {
            this.tail.next = node;
        }

        this.tail = node;
    }
};

function printSinglyLinkedList(node, sep, ws) {
    while (node != null) {
        ws.write(String(node.data));

        node = node.next;

        if (node != null) {
            ws.write(sep);
        }
    }
}

/*
 * Complete the 'insertNodeAtPosition' function below.
 *
 * The function is expected to return an INTEGER_SINGLY_LINKED_LIST.
 * The function accepts following parameters:
 *  1. INTEGER_SINGLY_LINKED_LIST llist
 *  2. INTEGER data
 *  3. INTEGER position
 */

/*
 * For your reference:
 *
 * SinglyLinkedListNode {
 *     int data;
 *     SinglyLinkedListNode next;
 * }
 *
 */

function insertNodeAtPosition(llist, data, position) {
    // Write your code here
	const newNode = new SinglyLinkedListNode(data);
	// Inserting at the head (position 0)
	if(position === 0) {
		newNode.next = llist;
		return newNode;
	}
	let current = llist;
	let currentPosition = 0;
	// Traverse to the node just before the insertion point
	while(current !== null && currentPosition < position - 1) {
		current = current.next;
		currentPosition++;
	}
	// Insert the new node
	newNode.next = current.next;
	current.next = newNode;
	return llist;
}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const llistCount = parseInt(readLine(), 10);

    let llist = new SinglyLinkedList();

    for (let i = 0; i < llistCount; i++) {
        const llistItem = parseInt(readLine(), 10);
        llist.insertNode(llistItem);
    }

    const data = parseInt(readLine(), 10);

    const position = parseInt(readLine(), 10);

    let llist_head = insertNodeAtPosition(llist.head, data, position);

    printSinglyLinkedList(llist_head, " ", ws)
    ws.write("\n");

    ws.end();
}
-----------------------------------------------------------------------------------------

Merge two sorted linked lists
Given pointers to the heads of two sorted linked lists, merge them into a single, sorted linked list. 
Either head pointer may be null meaning that the corresponding list is empty.
Example:
headA refers to 1 --> 3 --> 7 --> NULL
headB refers to 1 --> 2 --> NULL
The new list is 1 --> 1 --> 2 --> 3 --> 7 --> NULL
Function Description:
Complete the mergeLists function in the editor below.
mergeLists has the following parameters:
* SinglyLinkedListNode pointer headA: a reference to the head of a list
* SinglyLinkedListNode pointer headB: a reference to the head of a list
Returns:
* SinglyLinkedListNode pointer: a reference to the head of the merged list
Input Format:
The first line contains an integer t, the number of test cases.
The format for each test case is as follows:
The first line contains an integer n, the length of the first linked list.
The next n lines contain an integer each, the elements of the linked list.
The next line contains an integer m, the length of the second linked list.
The next m lines contain an integer each, the elements of the second linked list.
Constraints:
1 <= t <= 10
1 <= n,m <= 1000
1 <= list[i] <= 1000, where list[i] is the i-th element of the list


'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', inputStdin => {
    inputString += inputStdin;
});

process.stdin.on('end', _ => {
    inputString = inputString.replace(/\s*$/, '')
        .split('\n')
        .map(str => str.replace(/\s*$/, ''));

    main();
});

function readLine() {
    return inputString[currentLine++];
}

const SinglyLinkedListNode = class {
    constructor(nodeData) {
        this.data = nodeData;
        this.next = null;
    }
};

const SinglyLinkedList = class {
    constructor() {
        this.head = null;
        this.tail = null;
    }

    insertNode(nodeData) {
        const node = new SinglyLinkedListNode(nodeData);

        if (this.head == null) {
            this.head = node;
        } else {
            this.tail.next = node;
        }

        this.tail = node;
    }
};

function printSinglyLinkedList(node, sep, ws) {
    while (node != null) {
        ws.write(String(node.data));

        node = node.next;

        if (node != null) {
            ws.write(sep);
        }
    }
}

// Complete the mergeLists function below.

/*
 * For your reference:
 *
 * SinglyLinkedListNode {
 *     int data;
 *     SinglyLinkedListNode next;
 * }
 *
 */
function mergeLists(head1, head2) {
	// Create a dummy node to simplify edge cases
	let dummy = new SinglyLinkedListNode(0);
	let tail = dummy;
	let a  = head1;
	let b = head2;
	while(a !== null && b !== null) {
		if(a.data <= b.data) {
			tail.next =  a;
			a = a.next;
		} else {
			tail.next = b;
			b = b.next;
		}
		tail = tail.next;
	}
	// Attach the remaining nodes, if any
	if(a !== null) {
		tail.next = a;
	} else if(b !== null) {
		tail.next = b;
	}
	// Return the merged list, skipping the dummy node
	return dummy.next;

}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const tests = parseInt(readLine(), 10);

    for (let testsItr = 0; testsItr < tests; testsItr++) {
        const llist1Count = parseInt(readLine(), 10);

        let llist1 = new SinglyLinkedList();

        for (let i = 0; i < llist1Count; i++) {
            const llist1Item = parseInt(readLine(), 10);
            llist1.insertNode(llist1Item);
        }
      
      	const llist2Count = parseInt(readLine(), 10);

        let llist2 = new SinglyLinkedList();

        for (let i = 0; i < llist2Count; i++) {
            const llist2Item = parseInt(readLine(), 10);
            llist2.insertNode(llist2Item);
        }

        let llist3 = mergeLists(llist1.head, llist2.head);

        printSinglyLinkedList(llist3, " ", ws)
        ws.write("\n");
    }

    ws.end();
}
----------------------------------------------------------------------------------

Ice Cream Parlor
Two friends like to pool their money and go to the ice cream parlor. T
hey always choose two distinct flavors and they spend all of their money.
Given a list of prices for the flavors of ice cream, select the two that will cost all of the money they have.
Example: m = 6 cost=[1,3,4,5,6] 
The two flavors that cost 1 and 5 meet the criteria. Using 1-based indexing, they are at indices 1 and 4.
Function Description:
Complete the icecreamParlor function in the editor below.
icecreamParlor has the following parameter(s):
* int m: the amount of money they have to spend
* int cost[n]: the cost of each flavor of ice cream
Returns:
* int[2]: the indices of the prices of the two flavors they buy, sorted ascending
Input Format:
The first line contains an integer, t, the number of trips to the ice cream parlor. The next t sets of lines each describe a visit.
Each trip is described as follows:
1. The integer m, the amount of money they have pooled.
2. The integer n, the number of flavors offered at the time.
3. n space-separated integers denoting the cost of each flavor: cost[cost[1],cost[2],...,cost[n]].
Note: The index within the cost array represents the flavor of the ice cream purchased.
Constraints:
1 <= t <= 50
2 <= m <= 10^4
2 <= n <= 10^4
1 <= cost[i] <= 10^4, for each i that belongs to [1,n]
There will always be a unique solution.

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}

/*
 * Complete the 'icecreamParlor' function below.
 *
 * The function is expected to return an INTEGER_ARRAY.
 * The function accepts following parameters:
 *  1. INTEGER m
 *  2. INTEGER_ARRAY arr
 */

function icecreamParlor(m, arr) {
    // Write your code here
	const flavorMap = new Map();
	for(let i = 0; i < arr.length; i++) {
		const complement = m - arr[i];
		if(flavorMap.has(complement)) {
			return[flavorMap.get(complement), i + 1].sort((a, b) => a - b);
		}
		flavorMap.set(arr[i], i + 1);
	}
	return [];
}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const t = parseInt(readLine().trim(), 10);

    for (let tItr = 0; tItr < t; tItr++) {
        const m = parseInt(readLine().trim(), 10);

        const n = parseInt(readLine().trim(), 10);

        const arr = readLine().replace(/\s+$/g, '').split(' ').map(arrTemp => parseInt(arrTemp, 10));

        const result = icecreamParlor(m, arr);

        ws.write(result.join(' ') + '\n');
    }

    ws.end();
}
---------------------------------------------------------------------------------

Queue using two stacks
A queue is an abstract data type that maintains the order in which elements were added to it, 
allowing the oldest elements to be removed from the front and new elements to be added to the rear. 
This is called a First-In-First-Out (FIFO) data structure because the first element added to the queue 
(i.e., the one that has been waiting the longest) is always the first one to be removed.
A basic queue has the following operations:
* Enqueue: add a new element to the end of the queue.
* Dequeue: remove the element from the front of the queue and return it.
In this challenge, you must first implement a queue using two stacks. Then process q queries, 
where each query is one of the following 3 types:
1: Enqueue element x into the end of the queue.
2: Dequeue the element at the front of the queue.
3: Print the element at the front of the queue.
Input Format:
The first line contains a single integer, q, denoting the number of queries.
Each line i of the q subsequent lines contains a single query in the form described in the problem statement above. 
All three queries start with an integer denoting the query type, but only query 1 is followed by an additional 
space-separated value, x, denoting the value to be enqueued.
Constraints:
1 <= q <= 10^5
1 <= type <= 3
1 <= |x| <= 10^9
It is guaranteed that a valid answer exists for each query of type 3.


function processData(input) {
    //Enter your code here
	const lines = input.split('\n');
	const q = parseInt(lines[0], 10);
	const enqueueStack = [];
	const dequeueStack = [];
	for(let i = 1; i <= q; i++) {
		const line = lines[i].trim();
		if(!line) continue;
		const [type, x] = line.split(' ').map(Number);
		if(type === 1) {
			enqueueStack.push(x);
		} else {
			if(dequeueStack.length === 0) {
				while(enqueueStack.length > 0) {
					dequeueStack.push(enqueueStack.pop());
				}
			}
			if(type === 2) {
				dequeueStack.pop();
			} else if (type === 3) {
				console.log(dequeueStack[dequeueStack.length - 1]);
			}
		}
	}
} 

process.stdin.resume();
process.stdin.setEncoding("ascii");
_input = "";
process.stdin.on("data", function (input) {
    _input += input;
});

process.stdin.on("end", function () {
   processData(_input);
});
----------------------------------------------------------------------------------------

Waiter
You are a waiter at a party. There is a pile of numbered plates. Create an empty answers array. 
At each iteration, i, remove each plate from the top of the stack in order. 
Determine if the number on the plate is evenly divisible by the i-th prime number. 
If it is, stack it in pile B[i]. Otherwise, stack it in stack A[i]. 
Store the values in B[i] from top to bottom in answers. In the next iteration, do the same with the values in stack A[i]. 
Once the required number of iterations is complete, store the remaining values in A[i] in answers, again from top to bottom. 
Return the answers array.
Example:
A = [2,3,4,5,6,7]
q = 3
An abbreviated list of primes is [2,3,5,7,11,13]. Stack the plates in reverse order.
A[0] = [2,3,4,5,6,7]
answers = []
Begin iterations. On the first iteration, check if items are divisible by 2.
A[1] = [7,5,3]
B[1] = [6,4,2]
Move B[1] elements to answers.
answers = [2,4,6]
On the second iteration, test if A[1] elements are divisible by 3.
A[2] = [7,5]
B[2] = [3]
Move B[2] elmements to answers.
answers = [2,4,6,3]
And on the third iteration, test if A[2] elements are divisible by 5.
A[3] = [7]
B[3] = [5]
Move B[3] elmements to answers.
answers = [2,4,6,3,5]
All iterations are complete, so move the remaining elements in A[3], from top to bottom, to answers.
answers = [2,4,6,3,5,7]. Return this list.
Function Description:
Complete the waiter function in the editor below.
waiter has the following parameters:
* int number[n]: the numbers on the plates
* int q: the number of iterations
Returns:
* int[n]: the numbers on the plates after processing
Input Format:
The first line contains two space separated integers, n and q.
The next line contains n space separated integers representing the initial pile of plates, i.e., A.
Constraints:
1 <= n <= 10^4
2 <= number[i] <= 10^4
1 <= q <= 1200

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}

/*
 * Complete the 'waiter' function below.
 *
 * The function is expected to return an INTEGER_ARRAY.
 * The function accepts following parameters:
 *  1. INTEGER_ARRAY number
 *  2. INTEGER q
 */

function waiter(number, q) {
    // Write your code here
	// Generate the first q primes
	function getPrimes(n) {
		const primes = [];
		let candidate = 2;
		while(primes.length < n) {
			let isPrime = true;
			for(const p of primes) {
				if(p * p > candidate) break;
				if(candidate % p === 0) {
					isPrime = false;
					break;
				}
			}
			if(isPrime) {
				primes.push(candidate);
			}
			candidate++;
		}
		return primes;
	}
	const primes = getPrimes(q);
	let currentA = [...number];
	const answers = [];
	for(let i = 0; i < q; i++) {
		const prime = primes[i];
		const B = [];
		const newA = [];
		// Process currentA from top (end) to bottom (start)
		for(let j = currentA.length - 1; j >= 0 ; j--) {
			const num = currentA[j];
			if(num % prime === 0) {
				B.push(num);
			} else {
				newA.push(num);
			}
		}
		// Add B elements in top-to-bottom order (reverse B)
		answers.push(...B.reverse());
		currentA = newA;
	}
	// Add remaining elements in currentA (topo-to-bottom)
	answers.push(...currentA.reverse());
	return answers;
}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const firstMultipleInput = readLine().replace(/\s+$/g, '').split(' ');

    const n = parseInt(firstMultipleInput[0], 10);

    const q = parseInt(firstMultipleInput[1], 10);

    const number = readLine().replace(/\s+$/g, '').split(' ').map(numberTemp => parseInt(numberTemp, 10));

    const result = waiter(number, q);

    ws.write(result.join('\n') + '\n');

    ws.end();
}
------------------------------------------------------------------------------------------

Balanced Brackets
A bracket is considered to be any one of the following characters: (, ), {, }, [, or ].
Two brackets are considered to be a matched pair if the an opening bracket (i.e., 
(, [, or {) occurs to the left of a closing bracket (i.e., ), ], or }) of the exact same type. 
There are three types of matched pairs of brackets: [], {}, and ().
A matching pair of brackets is not balanced if the set of brackets it encloses are not matched. 
For example, {[(])} is not balanced because the contents in between { and } are not balanced. 
The pair of square brackets encloses a single, unbalanced opening bracket, (, and 
the pair of parentheses encloses a single, unbalanced closing square bracket, ].
By this logic, we say a sequence of brackets is balanced if the following conditions are met:
* It contains no unmatched brackets.
* The subset of brackets enclosed within the confines of a matched pair of brackets is also a matched pair of brackets.
Given n strings of brackets, determine whether each sequence of brackets is balanced. 
If a string is balanced, return YES. Otherwise, return NO.
Function Description:
Complete the function isBalanced in the editor below.
isBalanced has the following parameter(s):
* string s: a string of brackets
Returns:
* string: either YES or NO
Input Format:
The first line contains a single integer n, the number of strings.
Each of the next n lines contains a single string s, a sequence of brackets.
Constraints:
1 <= n <= 10^3
1 <= |s| <= 10^3, where |s| is the length of the sequence.
All characters in the sequences belong to {{, }, (, ), [, ]}.

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}

/*
 * Complete the 'isBalanced' function below.
 *
 * The function is expected to return a STRING.
 * The function accepts STRING s as parameter.
 */

function isBalanced(s) {
    // Write your code here
	const stack = [];
	const pairs = {
		')': '(',
		'}': '{',
		']': '['
	};
	for(let i = 0; i < s.length; i++) {
		const char = s[i];
		if(char === '(' || char === '{' || char === '[') {
			stack.push(char);
		} else if(char === ')' || char === '}' || char === ']') {
			if(stack.length === 0 || stack[stack.length - 1] !==pairs[char]) {
				return "NO";
			}
			stack.pop();
		}
	}
	return stack.length === 0 ? "YES" : "NO";
}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const t = parseInt(readLine().trim(), 10);

    for (let tItr = 0; tItr < t; tItr++) {
        const s = readLine();

        const result = isBalanced(s);

        ws.write(result + '\n');
    }

    ws.end();
}
--------------------------------------------------------------------------------------------------------
Simple Text Editor
Implement a simple text editor. The editor initially contains an empty string, S. 
Perform Q operations of the following 4 types:
1. append(W) - Append string W to the end of S.
2. delete(k) - Delete the last k characters of S.
3. print(k) - Print the k-th character of S.
4. undo() - Undo the last (not previously undone) operation of type 1 or 2, 
reverting S to the state it was in prior to that operation.
Example:
S = 'abcde'
ops = ['1 fg', '3 6', '2 5', '4', '3 7', '4', '3 4']
operation
index   S       ops[index]  explanation
-----   ------  ----------  -----------
0       abcde   1 fg        append fg
1       abcdefg 3 6         print the 6th letter - f
2       abcdefg 2 5         delete the last 5 letters
3       ab      4           undo the last operation, index 2
4       abcdefg 3 7         print the 7th characgter - g
5       abcdefg 4           undo the last operation, index 0
6       abcde   3 4         print the 4th character - d
The results should be printed as:
f
g
d
Input Format:
The first line contains an integer, Q, denoting the number of operations.
Each line i of the Q subsequent lines (where 0 <= i <= Q) defines an operation to be performed. 
Each operation starts with a single integer, t (where t belongs to {1,2,3,4}), denoting a type of 
operation as defined in the Problem Statement above. If the operation requires an argument, 
t is followed by its space-separated argument. For example, if t = 1 and W = 'abcd', line i will be 1 abcd.
Constraints:
1 <= Q <= 10^6
1 <= k <= |S|
The sum of the lengths of all W in the input <= 10^6.
The sum of k over all delete operations <= 2x10^6.
All input characters are lowercase English letters.
It is guaranteed that the sequence of operations given as input is possible to perform.

function processData(input) {
    //Enter your code here
	const lines = input.trim().split('\n');
	const Q = parseInt(lines[0]);
	let S = [];
	const undoStack = [];
	let output = [];
	for(let i = 1; i <= Q; i++) {
		const parts = lines[i].split(' ');
		const op = parts[0];
		if(op === '1') { // append
			const W = parts[1];
			undoStack.push(['2', W.length]); // Save inverse: delete last W.length
			for(let j = 0; j < W.length; j++) S.push(W[j]);
		} else if(op === '2') { // delete
			const k = parseInt(parts[1]);
			const deleted = S.slice(S.length - k).join('');
			undoStack.push(['1', deleted]); // Save inverse: append deleted
			S.length -= k;
		} else if(op === '3') { // print
			const k = parseInt(parts[1]);
			output.push(S[k - 1]);
		} else if(op === '4') { // undo
			const last = undoStack.pop();
			if(last[0] === '1') { // undo delete: append last[1]
				for(let j = 0; j < last[1].length; j++) S.push(last[1][j]);
			} else if(last[0] === '2') { // undo append: delete last[1] chars
				S.length -= last[1];
			}
		}
	}
	console.log(output.join('\n'));
} 

process.stdin.resume();
process.stdin.setEncoding("ascii");
_input = "";
process.stdin.on("data", function (input) {
    _input += input;
});

process.stdin.on("end", function () {
   processData(_input);
});
------------------------------------------------------------------------------------------------------

Truck Tour
Suppose there is a circle. There are N petrol pumps on that circle. Petrol pumps are numbered 0 to (N-1)(both inclusive). You have
two pieces of information corresponding to each of the petrol pump: (1) the amount of petrol that particular petrol pump will give,
and (2) the distance from that petrol pump to the next petrol pump.
Initially, you have a tank of infinite capacity carrying no petrol. You can start the tour at any of the petrol pumps. 
Calculate the first point from where the truck will be able to complete the circle. Consider that the truck will stop at each of the petrol pumps.
The truck will move one kilometer for each litre of the petrol.
Input Format:
The first line contain the value of N.
The next N lines will contain a pair of integers each, i.e. the amount of petrol that petrol pump will give and the next petrol pump.
Constraints:
1 <= N <= 10^5
1 <= amount of petrol, distance <= 10^9

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}



/*
 * Complete the 'truckTour' function below.
 *
 * The function is expected to return an INTEGER.
 * The function accepts 2D_INTEGER_ARRAY petrolpumps as parameter.
 */

function truckTour(petrolpumps) {
    // Write your code here
	let start = 0;
	let currentPetrol = 0;
	let totalSurplus = 0;
	for(let i = 0; i < petrolpumps.length; i++) {
		const petrol = petrolpumps[i][0];
		const distance = petrolpumps[i][1];
		const surplus = petrol - distance;
		currentPetrol += surplus;
		totalSurplus += surplus;
		if(currentPetrol < 0) {
			start = i + 1;
			currentPetrol = 0;
		}
	}
	return start;

}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const n = parseInt(readLine().trim(), 10);

    let petrolpumps = Array(n);

    for (let i = 0; i < n; i++) {
        petrolpumps[i] = readLine().replace(/\s+$/g, '').split(' ').map(petrolpumpsTemp => parseInt(petrolpumpsTemp, 10));
    }

    const result = truckTour(petrolpumps);

    ws.write(result + '\n');

    ws.end();
}
----------------------------------------------------------------------------------------

Pairs
Given an array of integers and a target value, determine the number of pairs of array elements that have a difference
equal to the target value.
Example:
k = 1
arr = [1,2,3,4]
There are three values that differ by k = 1: 2-1=1, 3-2=1, and 4-3=1. Return 3.
Function Description:
Complete the pairs function.
pairs has the following parameters:
* int k: an integer, the target difference
* int arr[n]: an array of integers
Return:
* int: the number of pairs that satisfy the criterion.
Input Format:
The first line contains two space-separated integers n and k; the size of arr and the target value.
The second line contains n space-separated integers of the arr
Constraints:
2 <= n <= 10^5
0 <= k <= 10^9
0 < arr[i] <2^31 - 1
each integer arr[i] will be unique.
'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}



/*
 * Complete the 'pairs' function below.
 *
 * The function is expected to return an INTEGER.
 * The function accepts following parameters:
 *  1. INTEGER k
 *  2. INTEGER_ARRAY arr
 */

function pairs(k, arr) {
    // Write your code here
	if(k === 0) return 0;
	const set = new Set(arr);
	let count = 0;
	for(const x of arr) {
		if(set.has(x + k)) {
			count++;
		}
	}
	return count;

}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const firstMultipleInput = readLine().replace(/\s+$/g, '').split(' ');

    const n = parseInt(firstMultipleInput[0], 10);

    const k = parseInt(firstMultipleInput[1], 10);

    const arr = readLine().replace(/\s+$/g, '').split(' ').map(arrTemp => parseInt(arrTemp, 10));

    const result = pairs(k, arr);

    ws.write(result + '\n');

    ws.end();
}
-----------------------------------------------------------------------------

Big Sorting
Consider an array of numeric strings where each string is a positive number with anywhere from 1 to 10^6 digits.
Sort the array's elements in non-decreasing, or ascending order of their integer values and return the sorted array.
Example:
unsorted = ['1', '200', '150', '3']
Return the array['1', '3', '150', '200']
Function Description:
Complete the bigSorting function below.
bisSorting has the following parameters:
* string unsorted[n]: an unsorted array of integers as strings.
Returns:
* string[n]: the array sorted in numerical order
Input Format:
The first line contains an integer, n, the number of strings in usorted.
Each of the n subsequent lines contains an integer string, unsorted[i].
Constraints:
1 <= n <= 2x10^5
Each string is guaranteed to represent a positive integer.
There will be no leading zeros.
The total number of digits across all strings in unsorted is between 1 and 10^6 (inclusive).

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}



/*
 * Complete the 'bigSorting' function below.
 *
 * The function is expected to return a STRING_ARRAY.
 * The function accepts STRING_ARRAY unsorted as parameter.
 */

function bigSorting(unsorted) {
    // Write your code here
	return unsorted.sort((a, b) => {
		if(a.length !== b.length) {
			return a.length - b.length;
		} else {
			return a.localeCompare(b);
		}
	});

}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const n = parseInt(readLine().trim(), 10);

    let unsorted = [];

    for (let i = 0; i < n; i++) {
        const unsortedItem = readLine();
        unsorted.push(unsortedItem);
    }

    const result = bigSorting(unsorted);

    ws.write(result.join('\n') + '\n');

    ws.end();
}
-------------------------------------------------------------------------

Equal Stacks
You have three stacks of cylinders where each cylinder has the same diameter, but they may vary in height. 
You can change the height of a stack by removing and discarding its topmost cylinder any number of times.
Find the maximum possible height of the stacks such that all of the stacks are exactly the same height. 
This means you must remove zero or more cylinders from the top of zero or more of the three stacks until 
they are all the same height, then return the height.
Example:
h1 = [1,2,1,1]
h2 = [1,1,2]
h3 = [1,1]
There are 4, 3 and 2 cylinders in the three stacks, with their heights in the three arrays. 
Remove the top 2 cylinders from h1 (heights = [1, 2]) and from h2 (heights = [1, 1]) so that the three stacks 
all are 2 units tall. Return 2 as the answer.
Note: An empty stack is still a stack.
Function Description:
Complete the equalStacks function in the editor below.
equalStacks has the following parameters:
* int h1[n1]: the first array of heights
* int h2[n2]: the second array of heights
* int h3[n3]: the third array of heights
Returns:
* int: the height of the stacks when they are equalized
Input Format:
The first line contains three space-separated integers, n1, n2, and n3, the numbers of cylinders in stacks 1, 2, and 3. 
The subsequent lines describe the respective heights of each cylinder in a stack from top to bottom:
The second line contains n1 space-separated integers, the cylinder heights in stack 1. The first element is the top cylinder of the stack.
The third line contains n2 space-separated integers, the cylinder heights in stack 2. The first element is the top cylinder of the stack.
The fourth line contains n3 space-separated integers, the cylinder heights in stack 3. The first element is the top cylinder of the stack.
Constraints:
0 <= n1, n2, n3 <= 10^5
0 < height of any cylinder <= 100

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}

/*
 * Complete the 'equalStacks' function below.
 *
 * The function is expected to return an INTEGER.
 * The function accepts following parameters:
 *  1. INTEGER_ARRAY h1
 *  2. INTEGER_ARRAY h2
 *  3. INTEGER_ARRAY h3
 */

function equalStacks(h1, h2, h3) {
    // Write your code here
	// Helper to compute cumulative heights from top to bottom
	function cumulativeHeights(arr) {
		let cum = [];
		let sum = 0;
		for(let i = arr.length - 1; i >= 0; i--) {
			sum += arr[i];
			cum.push(sum);
		}
		cum.reverse();
		return cum;
	}
	let s1  = cumulativeHeights(h1);
	let s2 = cumulativeHeights(h2);
	let s3 = cumulativeHeights(h3);
	let i = 0, j = 0, k = 0;
	while(i < s1.length && j < s2.length && k < s3.length) {
		let h1h = s1[i], h2h = s2[j], h3h = s3[k];
		if(h1h === h2h && h2h === h3h) {
			return h1h;
		}
		// Remove from the tallest stack
		if(h1h >= h2h && h1h >= h3h) {
			i++;
		} else if(h2h >= h1h && h2h >= h3h) {
			j++;
		} else {
			k++;
		}
	}
	return 0;

}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const firstMultipleInput = readLine().replace(/\s+$/g, '').split(' ');

    const n1 = parseInt(firstMultipleInput[0], 10);

    const n2 = parseInt(firstMultipleInput[1], 10);

    const n3 = parseInt(firstMultipleInput[2], 10);

    const h1 = readLine().replace(/\s+$/g, '').split(' ').map(h1Temp => parseInt(h1Temp, 10));

    const h2 = readLine().replace(/\s+$/g, '').split(' ').map(h2Temp => parseInt(h2Temp, 10));

    const h3 = readLine().replace(/\s+$/g, '').split(' ').map(h3Temp => parseInt(h3Temp, 10));

    const result = equalStacks(h1, h2, h3);

    ws.write(result + '\n');

    ws.end();
}
-------------------------------------------------------------------------------------------
The Maximum Subarray
We define subsequence as any subset of an array. We define a subarray as a contiguous subsequence in an array.
Given an array, find the maximum possible sum among:
1. all nonempty subarrays.
2. all nonempty subsequences.
Print the two values as space-separated integers on one line.
Note that empty subarrays/subsequences should not be considered.
Example:
arr = [-1,2,3,-4,5,10]
The maximum subarray sum is comprised of elements at inidices [1 - 5]. Their sum is 2 + 3 + (-4) + 5 + 10 = 16. 
The maximum subsequence sum is comprised of elements at indices [1,2,4,5] and their sum is 2 + 3 + 5 + 10 = 20.
Function Description:
Complete the maxSubarray function in the editor below.
maxSubarray has the following parameter(s):
* int arr[n]: an array of integers
Returns:
* int[2]: the maximum subarray and subsequence sums
Input Format:
The first line of input contains a single integer t, the number of test cases.
The first line of each test case contains a single integer n.
The second line contains n space-separated integers arr[i] where 0 <= i < n.
Constraints:
1 <= t <= 10
1 <= n <= 10^5
-10^4 <= arr[i] <= 10^4
The subarray and subsequences considered should have at least one element.

'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}

/*
 * Complete the 'maxSubarray' function below.
 *
 * The function is expected to return an INTEGER_ARRAY.
 * The function accepts INTEGER_ARRAY arr as parameter.
 */

function maxSubarray(arr) {
    // Write your code here
	let max_ending_here = 0;
	let max_so_far = -Infinity;
	let non_contiguous = 0;
	let max_element = -Infinity;
	for(let num of arr) {
		max_ending_here = Math.max(num, max_ending_here + num);
		max_so_far = Math.max(max_so_far, max_ending_here);
		if(num > 0) {
			non_contiguous += num;
		}
		if(num > max_element) {
			max_element = num;
		}
	}
	if(non_contiguous === 0) {
		non_contiguous = max_element;
	}
	return [max_so_far, non_contiguous];
}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const t = parseInt(readLine().trim(), 10);

    for (let tItr = 0; tItr < t; tItr++) {
        const n = parseInt(readLine().trim(), 10);

        const arr = readLine().replace(/\s+$/g, '').split(' ').map(arrTemp => parseInt(arrTemp, 10));

        const result = maxSubarray(arr);

        ws.write(result.join(' ') + '\n');
    }

    ws.end();
}
-------------------------------------------------------------------------------------------------------






































































